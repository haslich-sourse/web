<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Stepan's Trial — подарок (исправлено v3)</title>
    <style>
      :root {
        --bg: #071427;
        --card: #0b1520;
        --accent: #d9b44a;
        --muted: #9fb0bf;
        --hp: #ef3b3b;
        --mana: #4aa3ff;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: Inter, Segoe UI, Arial, sans-serif;
        background: linear-gradient(180deg, #071427 0%, #041018 100%);
        color: #e6eef6;
        -webkit-font-smoothing: antialiased;
      }
      .wrap {
        max-width: 1000px;
        margin: 22px auto;
        padding: 18px;
      }
      header {
        display: flex;
        gap: 14px;
        align-items: center;
      }
      .logo {
        width: 78px;
        height: 78px;
        border-radius: 14px;
        background: linear-gradient(135deg, var(--accent), #e36d6d);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);

        overflow: hidden; /* обрезает содержимое по радиусу */
      }
      .logo img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: inherit;
        display: block;

        image-rendering: -webkit-optimize-contrast; /* Safari/Chrome */
        image-rendering: auto; /* браузеры подберут сглаживание */
        filter: contrast(0.95) brightness(1.05); /* чуть мягче */
      }

      h1 {
        margin: 0;
        font-size: 22px;
      }
      .lead {
        color: var(--muted);
        margin-top: 6px;
        font-size: 14px;
      }
      .card {
        background: rgba(255, 255, 255, 0.03);
        padding: 16px;
        border-radius: 12px;
        margin-top: 16px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
      }
      .row {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .btn {
        background: var(--accent);
        border: none;
        padding: 10px 14px;
        border-radius: 10px;
        color: #081220;
        font-weight: 800;
        cursor: pointer;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.5);
      }
      .btn.secondary {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.06);
        color: var(--muted);
        font-weight: 700;
      }
      .muted {
        color: var(--muted);
        font-size: 13px;
      }
      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(2, 6, 10, 0.85);
        z-index: 70;
      }
      .modal.show {
        display: flex;
      }
      .modal img {
        max-width: 94vw;
        max-height: 92vh;
        border-radius: 8px;
        box-shadow: 0 18px 80px rgba(0, 0, 0, 0.7);
      }
      .modal .close {
        position: absolute;
        top: 18px;
        right: 18px;
        background: rgba(255, 255, 255, 0.06);
        border-radius: 8px;
        padding: 8px;
        color: #e6eef6;
        cursor: pointer;
      }
      #gameWrap {
        margin-top: 14px;
        display: flex;
        gap: 12px;
        align-items: flex-start;
      }
      canvas {
        background: transparent;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
        display: block;
      }
      #sidebar {
        width: 260px;
      }
      .hud {
        background: rgba(255, 255, 255, 0.02);
        padding: 10px;
        border-radius: 10px;
        font-size: 14px;
        color: var(--muted);
      }
      .bar {
        height: 12px;
        background: rgba(255, 255, 255, 0.04);
        border-radius: 8px;
        overflow: hidden;
        margin-top: 8px;
      }
      .center {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 80;
      }
      .dialog {
        background: linear-gradient(180deg, #071422, #081522);
        padding: 20px;
        border-radius: 12px;
        max-width: 720px;
        color: #dbe9ff;
        border: 1px solid rgba(255, 255, 255, 0.03);
      }
      .dialog h3 {
        margin: 0 0 8px 0;
      }
      /* --- enemy dialog layout --- */
      .enemy-dialog {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .enemy-dialog .enemy-img {
        width: 84px;
        height: 84px;
        border-radius: 8px;
        overflow: hidden;
        flex: 0 0 84px;
        background: #071421;
        display: inline-block;
      }
      .enemy-dialog .enemy-img img {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
        object-position: top; /* для "верхней части" */
      }
      /* если хотим НЕ обрезать (уровень 3) — добавляем класс no-crop */
      .enemy-dialog .enemy-img.no-crop img {
        object-fit: contain;
        object-position: center;
        background: transparent;
      }
      /* текстовая часть справа */
      .enemy-dialog .enemy-meta {
        flex: 1 1 auto;
      }
      .enemy-dialog .enemy-name {
        font-weight: 800;
        font-size: 16px;
        margin-bottom: 6px;
        color: #ffd76b;
      }
      .enemy-dialog .enemy-taunt {
        color: #dbe9ff;
        font-size: 13px;
      }

      .choices {
        display: flex;
        gap: 8px;
        margin-top: 10px;
        flex-wrap: wrap;
      }
      .choice {
        background: rgba(255, 255, 255, 0.03);
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        border: 1px solid rgba(255, 255, 255, 0.03);
      }
      .goyda {
        position: absolute;
        left: 50%;
        top: 20%;
        transform: translateX(-50%);
        font-size: 64px;
        font-weight: 900;
        color: #ffd76b;
        text-shadow: 0 6px 24px rgba(0, 0, 0, 0.6);
        pointer-events: none;
        z-index: 95;
        opacity: 0;
        transition: opacity 0.18s, transform 0.2s;
      }
      .goyda.show {
        opacity: 1;
        transform: translateX(-50%) scale(1.06);
      }
      footer {
        margin-top: 18px;
        color: var(--muted);
        font-size: 13px;
        text-align: center;
      }
      @media (max-width: 980px) {
        .wrap {
          padding: 12px;
        }
        #gameWrap {
          flex-direction: column;
        }
        #sidebar {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div class="logo">
          <img src="assets/wall3.jpg" alt="Логотип" />
        </div>

        <div>
          <h1>Достойный Испытание — Путь Степана</h1>
          <div class="lead">
            Открой дверь — и начнётся церемония. Это не просто игра. Это —
            вызов, дань уважения лысины и торжество вкуса.
          </div>
        </div>
      </header>

      <div class="card" id="introCard">
        <div id="introText" style="white-space: pre-wrap"></div>
        <div style="margin-top: 12px" class="row">
          <button class="btn" id="showEggBtn">Показать яйцо</button>
          <button class="btn" id="playBtnTop">Играть</button>
          <button class="btn secondary" id="downloadBtn">Скачать (zip)</button>
        </div>
        <div style="margin-top: 10px" class="muted">
          Просто нажми и посмотри.
        </div>
      </div>

      <div id="gameWrap">
        <canvas id="game" width="800" height="520"></canvas>
        <div id="sidebar">
          <div class="hud card">
            <div style="font-weight: 700">Степан — герой</div>
            <div style="margin-top: 8px">HP</div>
            <div class="bar">
              <i
                id="hpBar"
                style="
                  width: 100%;
                  background: var(--hp);
                  display: block;
                  height: 100%;
                "
              ></i>
            </div>
            <div style="margin-top: 8px">Mana</div>
            <div class="bar">
              <i
                id="manaBar"
                style="
                  width: 100%;
                  background: var(--mana);
                  display: block;
                  height: 100%;
                "
              ></i>
            </div>
            <div style="margin-top: 10px" class="muted">
              Управление: WASD/стрелки — движение, пробел — удар, E — ГООООЙДА.
            </div>
            <div style="margin-top: 12px">
              <strong id="scoreText">Очки: 0</strong>
            </div>
            <div style="margin-top: 8px" class="muted" id="levelText">
              Уровень: 0 / 3
            </div>
            <div style="margin-top: 12px" class="center">
              <button class="btn" id="startBtn">Старт</button>
            </div>
          </div>

          <div style="height: 12px"></div>

          <div class="card hud" id="flavorCard">
            <div style="font-weight: 700">Небольшие свершения</div>
            <div class="muted" style="margin-top: 8px" id="flavorText">
              Степан — любит сало, Камчатку, Доту и показывать яйца. Покажи свою
              Степанность — и мир прогнётся.
            </div>
          </div>
          <div class="card hud" id="audioControls" style="margin-top: 12px">
            <div style="font-weight: 700">Звук и музыка</div>

            <div style="margin-top: 8px" class="muted">
              Эффекты <span id="effectsVal">90%</span>
            </div>
            <input
              id="effectsVol"
              type="range"
              min="0"
              max="1"
              step="0.01"
              value="0.9"
            />

            <div style="margin-top: 8px" class="muted">
              Фоновая музыка <span id="musicVal">60%</span>
            </div>
            <input
              id="musicVol"
              type="range"
              min="0"
              max="1"
              step="0.01"
              value="0.6"
            />
            <!-- music player: отображается, когда загружена музыка -->
            <audio
              id="musicPlayer"
              controls
              style="width: 100%; margin-top: 8px; display: none"
            ></audio>
          </div>
        </div>
      </div>
      <!-- ====== Большой плеер музыки (под игрой) ====== -->
      <div
        id="musicPlayerContainer"
        style="max-width: 1000px; margin: 12px auto"
      >
        <div class="card hud" id="musicPlayerCard" style="padding: 12px">
          <div style="font-weight: 700">Плеер фоновой музыки</div>

          <div
            style="
              display: flex;
              gap: 10px;
              align-items: center;
              margin-top: 10px;
            "
          >
            <button
              id="musicPlayBtn"
              class="btn secondary"
              style="min-width: 86px"
            >
              Play
            </button>

            <input
              id="musicSeek"
              type="range"
              min="0"
              max="1000"
              value="0"
              step="1"
              style="
                flex: 1;
                appearance: none;
                height: 10px;
                border-radius: 6px;
                background: transparent;
              "
            />

            <div
              id="musicTime"
              class="muted"
              style="width: 130px; text-align: right; font-size: 13px"
            >
              0:00 / 0:00
            </div>
          </div>

          <div style="margin-top: 8px" class="muted">
            Если автоплей заблокирован — нажми Play на плеере.
          </div>
        </div>
      </div>
      <!-- Скрытый DOM-аудио (используется как источник, управление через UI выше) -->
      <audio id="musicPlayer" preload="auto" style="display: none"></audio>
      <!-- ====== /Большой плеер музыки ====== -->

      <footer>Подвал с <code>детьми</code>.</footer>
    </div>

    <div class="modal" id="eggModal">
      <div class="close" id="eggClose">✕</div>
      <img id="eggImg" src="assets/egg_full.png" alt="egg" />
    </div>

    <div id="overlayRoot" class="overlay" style="display: none"></div>
    <div id="goydaText" class="goyda">ГООООЙДА</div>

    <script>
      /* =============================
   CONFIG (тексты / пути / баланс)
   ============================= */
      const SOUND_LISTS = {
        goyda: ["assets/sounds/goyda.mp3"],

        // атаки — список вариантов, проигрывается случайный
        attack: [
          "assets/sounds/attack1.mp3",
          "assets/sounds/attack2.mp3",
          "assets/sounds/attack3.mp3",
          "assets/sounds/attack4.mp3",
          "assets/sounds/attack5.mp3",
          "assets/sounds/attack6.mp3",
          "assets/sounds/attack7.mp3",
          "assets/sounds/attack8.mp3",
          "assets/sounds/attack9.mp3",
          "assets/sounds/attack10.mp3",
          "assets/sounds/attack11.mp3",
        ],

        // звуки получения урона
        hurt: [
          "assets/sounds/hurt1.mp3",
          "assets/sounds/hurt2.mp3",
          "assets/sounds/hurt3.mp3",
          "assets/sounds/hurt4.mp3",
          "assets/sounds/hurt5.mp3",
        ],
      };
      SOUND_LISTS.pickup_heart = [
        "assets/sounds/pickup1.mp3",
        "assets/sounds/pickup2.mp3",
        "assets/sounds/pickup3.mp3",
        "assets/sounds/pickup4.mp3",
        // добавь свои варианты сердец сюда
      ];

      SOUND_LISTS.pickup_mana = [
        "assets/sounds/mana1.mp3",
        "assets/sounds/mana2.mp3",
        "assets/sounds/mana3.mp3",
        // добавь свои варианты маны сюда
      ];
      SOUND_LISTS.victory = ["assets/sounds/victory1.mp3"];
      SOUND_LISTS.defeat = ["assets/sounds/defeat1.mp3"];
      // --- музыка по уровням ---
      const MUSIC_LIST = [
        "assets/music/level1.mp3", // уровень 0
        "assets/music/level2.mp3", // уровень 1
        "assets/music/level3.mp3", // уровень 2
      ];
      // runtime-хранилище загруженных Audio объектов
      const SOUNDS = {}; // ключ -> [HTMLAudio, HTMLAudio, ...]
      // audio runtime settings
      let effectsVolume = 0.9;
      let musicVolume = 0.6;
      let effectsMuted = false;
      let musicMuted = false;

      // music runtime
      const MUSIC = []; // preloaded HTMLAudio objects for music
      let currentMusic = null;

      // --- attack sound single-instance + acceleration ---
      let currentAttackAudio = null; // активный экземпляр attack звука
      let attackAccelStep = 1.25; // во сколько раз ускоряется звук при повторном нажатии
      let attackMaxRate = 2.2; // максимальный playbackRate
      let attackBaseVolume = 0.9; // базовый volume для клона
      const TEXTS = {
        introLong: `Воистину, в день сей мир заметит свет — сияние лысой главы великого Степана. 
Сегодня ты не просто отмечаешь двадцать первый год — сегодня случится эпопея.

Степа, с ДР! Но это лишь прелюдия. Чтобы получить свой дар, предстоит пройти обряд:
озарить мир сверканием своей лысины, победить свирепое Сало, показать яйца в знак мужества и, выкрикнув "ГООООЙДА", пройти через Рыбную Ленту.

Твои залысины  — это факел; твоя смелость — щит. Приготовься: испытание ждёт.`,
        gotoExitText:
          "Все враги повержены! Теперь доберись до выхода (жёлтая метка).",
        victoryTitle: "Победа!",
        victoryText:
          "Степан, ты прошёл все испытания. Возьми свой подарок — он заслужен.",
        gameOverTitle: "Поражение",
        gameOverText:
          "Не печалься — попробуй снова, и пусть лысины свет вновь ведёт тебя.",
      };

      const ASSETS = {
        player: "assets/player.png",
        enemy1: "assets/enemy1.png",
        boss: "assets/enemy_boss.png",
        heart: "assets/heart.png",
        mana: "assets/mana.png",
        egg: "assets/egg_full.png",
      };
      // Перечень дополнительных картинок для каждого уровня (ключи — совпадают с тем, что мы рисуем в render)
      const ASSETS_LEVEL = [
        // level 0: пока пусто (использует ASSETS по-умолчанию)
        {
          floor: "assets/floor_level0.jpg",
          wallVariants: [
            "assets/wall0_a.jpg",
            "assets/wall0_b.jpg",
            "assets/wall0_c.jpg",
            "assets/wall0_d.jpg",
            "assets/wall0_3.jpg",
            "assets/wall1.jpg",
            "assets/wall2.jpg",
            "assets/wall3.jpg",
            "assets/wall4.jpg",
            "assets/wall5.jpg",
            "assets/wall6.jpg",
            "assets/wall7.jpg",
            "assets/wall8.jpg",
            "assets/wall9.jpg",
            "assets/wall10.jpg",
            "assets/wall11.jpg",
            "assets/wall12.jpg",
            "assets/wall13.jpg",
            "assets/wall14.jpg",
            "assets/wall15.jpg",
            "assets/wall16.jpg",
            "assets/wall17.jpg",
            "assets/wall18.jpg",
            "assets/wall19.jpg",
            "assets/wall20.jpg",
            "assets/wall21.jpg",
            "assets/wall22.jpg",
            "assets/wall23.jpg",
            "assets/wall24.jpg",
            "assets/wall25.jpg",
            "assets/wall26.jpg",
            "assets/wall27.jpg",
            "assets/wall28.jpg",
            "assets/wall29.jpg",
            "assets/wall30.jpg",
          ],
        },
        // level 1: более злые враги (положи файлы в assets/)
        {
          enemy_lvl2: "assets/enemy_lvl2.png",
          boss_lvl2: "assets/enemy_boss_lvl2.png",
          player_lvl2: "assets/player_lvl2.png",
          floor: "assets/floor_level1.png",
          wallVariants: [
            "assets/wall1_a.png",
            "assets/wall1_b.png",
            "assets/wall1_c.png",
          ],
        },
        // level 2: ещё другие картинки
        {
          enemy_lvl3: "assets/enemy_lvl3.png",
          boss_lvl3: "assets/enemy_boss_lvl3.png",
          player_lvl3: "assets/player_lvl3.png",
          floor: "assets/floor_level2.png",
          wallVariants: [
            "assets/wall2_a.png",
            "assets/wall2_b.png",
            "assets/wall2_c.png",
            "assets/wall2_d.png",
          ],
        },
      ];

      const BALANCE = {
        playerMaxHP: 100,
        playerMaxMana: 100,
        baseDamage: 20,
        superCost: 40,
        superDamage: 120,
        heartHeal: 25,
        manaRestore: 40,
      };
      // Конфиг уровней: для каждого уровня задаём базовый count, множители HP/Speed, и имена ассетов уровня
      const LEVEL_CONFIG = [
        // уровень 0 (текущий/лабиринт) — оставить примерно как было
        {
          enemyCount: 6,
          hpMult: 1.0,
          speedMult: 1.0,
          enemyImage: "enemy1",
          bossImage: "boss",
        },
        // уровень 1 (мы сделаем более сложным)
        {
          enemyCount: 10,
          hpMult: 1.6,
          speedMult: 1.35,
          enemyImage: "enemy_lvl2",
          bossImage: "boss_lvl2",
        },
        // уровень 2 (финал) — ещё горячее
        {
          enemyCount: 14,
          hpMult: 2.0,
          speedMult: 1.6,
          enemyImage: "enemy_lvl3",
          bossImage: "boss_lvl3",
        },
      ];

      /* =============================
   BASICS
   ============================= */
      const canvas = document.getElementById("game");
      // сделать canvas фокусируемым и фокусировать при клике/таче
      canvas.tabIndex = 0;
      canvas.addEventListener("pointerdown", () => {
        try {
          canvas.focus();
        } catch (e) {}
      });

      const ctx = canvas.getContext("2d");
      const W = canvas.width,
        H = canvas.height;
      document.getElementById("introText").textContent = TEXTS.introLong;
      document.getElementById("showEggBtn").addEventListener("click", () => {
        showEggModal();
      });
      document.getElementById("eggClose").addEventListener("click", () => {
        hideEggModal();
      });
      document.getElementById("playBtnTop").addEventListener("click", () => {
        startGame();
        // после startGame() выполните:
        const startBtn = document.getElementById("startBtn");
        if (startBtn) startBtn.blur();
        const c = document.getElementById("game");
        if (c) {
          c.tabIndex = 0; // чтобы canvas мог получать фокус
          try {
            c.focus();
          } catch (e) {
            /* ignore */
          }
        }
      });
      document.getElementById("startBtn").addEventListener("click", () => {
        startGame();
        // после startGame() выполните:
        const startBtn = document.getElementById("startBtn");
        if (startBtn) startBtn.blur();
        const c = document.getElementById("game");
        if (c) {
          c.tabIndex = 0; // чтобы canvas мог получать фокус
          try {
            c.focus();
          } catch (e) {
            /* ignore */
          }
        }
      });
      // -----------------------------
      // Audio controls wiring — подключаем слушатели ОДИН РАЗ
      // -----------------------------
      function wireAudioControls() {
        const effectsVolEl = document.getElementById("effectsVol");
        const musicVolEl = document.getElementById("musicVol");
        const effectsVal = document.getElementById("effectsVal");
        const musicVal = document.getElementById("musicVal");

        // начальные значения в UI
        if (effectsVal)
          effectsVal.textContent = Math.round(effectsVolume * 100) + "%";
        if (musicVal)
          musicVal.textContent = Math.round(musicVolume * 100) + "%";
        if (effectsVolEl) effectsVolEl.value = effectsVolume;
        if (musicVolEl) musicVolEl.value = musicVolume;

        if (effectsVolEl) {
          effectsVolEl.addEventListener("input", (e) => {
            effectsVolume = parseFloat(e.target.value);
            if (effectsVal)
              effectsVal.textContent = Math.round(effectsVolume * 100) + "%";
          });
        }

        if (musicVolEl) {
          musicVolEl.addEventListener("input", (e) => {
            musicVolume = parseFloat(e.target.value);
            if (musicVal)
              musicVal.textContent = Math.round(musicVolume * 100) + "%";
            if (currentMusic && !musicMuted) currentMusic.volume = musicVolume;
          });
        }

        // Создаём/подвязываем кнопки включения/выключения музыки/эффектов (если их нет)
        let toggleEffectsBtn = document.getElementById("toggleEffects");
        let toggleMusicBtn = document.getElementById("toggleMusic");

        if (!toggleEffectsBtn) {
          toggleEffectsBtn = document.createElement("button");
          toggleEffectsBtn.id = "toggleEffects";
          toggleEffectsBtn.className = "btn secondary";
          toggleEffectsBtn.style.marginTop = "8px";
          toggleEffectsBtn.textContent = effectsMuted
            ? "Вкл. эффекты"
            : "Откл. эффекты";
          const ac = document.getElementById("audioControls");
          if (ac) ac.appendChild(toggleEffectsBtn);
        }
        if (!toggleMusicBtn) {
          toggleMusicBtn = document.createElement("button");
          toggleMusicBtn.id = "toggleMusic";
          toggleMusicBtn.className = "btn secondary";
          toggleMusicBtn.style.marginTop = "8px";
          toggleMusicBtn.textContent = musicMuted
            ? "Вкл. музыку"
            : "Откл. музыку";
          const ac = document.getElementById("audioControls");
          if (ac) ac.appendChild(toggleMusicBtn);
        }

        if (toggleEffectsBtn) {
          toggleEffectsBtn.addEventListener("click", () => {
            effectsMuted = !effectsMuted;
            toggleEffectsBtn.textContent = effectsMuted
              ? "Вкл. эффекты"
              : "Откл. эффекты";
          });
        }
        if (toggleMusicBtn) {
          toggleMusicBtn.addEventListener("click", () => {
            musicMuted = !musicMuted;
            toggleMusicBtn.textContent = musicMuted
              ? "Вкл. музыку"
              : "Откл. музыку";
            if (currentMusic)
              currentMusic.volume = musicMuted ? 0 : musicVolume;
          });
        }
      }
      /***** Большой плеер: UI + логика перемотки *****/
      function formatTimeSec(s) {
        s = Math.max(0, Math.floor(s || 0));
        const mm = Math.floor(s / 60);
        const ss = s % 60;
        return mm + ":" + (ss < 10 ? "0" + ss : ss);
      }

      function wireMusicPlayerUI() {
        const audio = document.getElementById("musicPlayer");
        const playBtn = document.getElementById("musicPlayBtn");
        const seek = document.getElementById("musicSeek");
        const timeDisplay = document.getElementById("musicTime");
        if (!audio || !playBtn || !seek || !timeDisplay) return;

        let isSeeking = false;
        let seekWhilePaused = false;

        // показываем кнопку в правильном состоянии
        function updatePlayBtn() {
          playBtn.textContent = audio && !audio.paused ? "Pause" : "Play";
        }

        // обновление прогресса (на каждый tick)
        audio.addEventListener("timeupdate", () => {
          if (isSeeking) return; // пользователь держит ползунок — не перезаписываем позицию
          const dur = audio.duration || 0;
          if (dur > 0) {
            const pct = Math.floor((audio.currentTime / dur) * 1000);
            seek.value = pct;
            timeDisplay.textContent = `${formatTimeSec(
              audio.currentTime
            )} / ${formatTimeSec(dur)}`;
          } else {
            // если длительность неизвестна — ставим на 0/0
            timeDisplay.textContent = `${formatTimeSec(
              audio.currentTime
            )} / 0:00`;
          }
        });

        // когда метаданные загружены — узнаём длительность и установим max
        audio.addEventListener("loadedmetadata", () => {
          const dur = audio.duration || 0;
          if (isFinite(dur) && dur > 0) {
            timeDisplay.textContent = `${formatTimeSec(
              audio.currentTime
            )} / ${formatTimeSec(dur)}`;
            // seek уже 0..1000, будет обновляться по timeupdate
          }
          updatePlayBtn();
        });

        audio.addEventListener("play", () => updatePlayBtn());
        audio.addEventListener("pause", () => updatePlayBtn());
        audio.addEventListener("ended", () => updatePlayBtn());

        // Play / Pause кнопка
        playBtn.addEventListener("click", () => {
          // попытка воспроизведения — если браузер блокирует, пользователь сможет нажать
          if (audio.paused) {
            const p = audio.play();
            if (p && typeof p.then === "function") {
              p.catch((err) => {
                // если play() заблокирован — оставим кнопку как Play и покажем предупреждение в консоли
                console.warn("[musicPlayer] play blocked", err);
              });
            }
          } else {
            audio.pause();
          }
        });

        // Прогресс — начало drag
        seek.addEventListener(
          "pointerdown",
          () => {
            isSeeking = true;
            seekWhilePaused = audio.paused;
          },
          { passive: true }
        );

        // обновление положения в процессе перемещения (для отзывчивости)
        seek.addEventListener(
          "input",
          (e) => {
            const v = parseInt(e.target.value, 10) || 0;
            const dur = audio.duration || 0;
            if (dur > 0) {
              const t = (v / 1000) * dur;
              timeDisplay.textContent = `${formatTimeSec(t)} / ${formatTimeSec(
                dur
              )}`;
            }
          },
          { passive: true }
        );

        // конец drag (или клик) -> seek to
        function finishSeek() {
          if (!isSeeking) return;
          isSeeking = false;
          const v = parseInt(seek.value, 10) || 0;
          const dur = audio.duration || 0;
          if (dur > 0) {
            const t = (v / 1000) * dur;
            try {
              audio.currentTime = t;
            } catch (e) {
              // некоторые браузеры/ресурсы могут бросать, но в основном это ок
            }
            // если плеер был на паузе и пользователь отпустил ползунок — оставим паузу
            if (seekWhilePaused) {
              audio.pause();
            } else {
              // попытка возобновить, если ранее хотели играть
              const p = audio.play();
              if (p && typeof p.then === "function") p.catch(() => {});
            }
          }
        }
        seek.addEventListener("pointerup", finishSeek);
        seek.addEventListener("change", finishSeek);
        // на случай, если pointercancel
        seek.addEventListener("pointercancel", finishSeek);

        // make sure the visible UI is in sync at load
        updatePlayBtn();
      }

      document.getElementById("downloadBtn").addEventListener("click", () => {
        alert(
          "Собери папку: index.html + assets/ и запакуй; напиши если нужен скрипт."
        );
      });
      function showEggModal() {
        const m = document.getElementById("eggModal");
        document.getElementById("eggImg").src = ASSETS.egg;
        m.classList.add("show");
      }
      function hideEggModal() {
        document.getElementById("eggModal").classList.remove("show");
      }

      /* =============================
   IMAGE LOADER
   ============================= */
      const IMAGES = {};
      // временные ключи для текущего уровня: имена ключей wallVar0..wallVarN
      let TEMP_WALL_KEYS = [];

      function loadImages(list, callback) {
        const keys = Object.keys(list);
        let loaded = 0;
        if (keys.length === 0) {
          callback();
          return;
        }
        keys.forEach((k) => {
          const img = new Image();
          img.src = list[k];
          img.onload = () => {
            IMAGES[k] = img;
            if (++loaded === keys.length) callback();
          };
          img.onerror = () => {
            IMAGES[k] = null;
            if (++loaded === keys.length) callback();
          };
        });
      }
      function loadSounds(list, callback) {
        const keys = Object.keys(list);
        if (keys.length === 0) {
          callback();
          return;
        }
        let loaded = 0;
        keys.forEach((key) => {
          let arr = list[key];
          if (!Array.isArray(arr)) {
            arr = [arr];
          }

          SOUNDS[key] = [];
          let innerLoaded = 0;
          if (arr.length === 0) {
            loaded++;
            if (loaded === keys.length) callback();
            return;
          }
          arr.forEach((src) => {
            const a = new Audio();
            a.preload = "auto";
            a.src = src;
            // mark as can play when metadata or enough data loaded
            a.addEventListener(
              "canplaythrough",
              () => {
                // ничего не делаем кроме учета
              },
              { once: true }
            );
            // учитываем и для error — чтобы не зависнуть на 404
            const finishOne = () => {
              innerLoaded++;
              SOUNDS[key].push(a);
              if (innerLoaded === arr.length) {
                loaded++;
                if (loaded === keys.length) callback();
              }
            };
            a.addEventListener("loadeddata", finishOne, { once: true });
            a.addEventListener(
              "error",
              () => {
                // если не загрузился — всё равно пушим объект (он будет null-checked при воспроизводстве)
                console.warn("[loadSounds] failed to load", src);
                innerLoaded++;
                // не пушим нерабочий элемент
                if (innerLoaded === arr.length) {
                  loaded++;
                  if (loaded === keys.length) callback();
                }
              },
              { once: true }
            );
          });
        });
      }
      function loadMusic(list, callback) {
        MUSIC.length = 0;
        if (!Array.isArray(list) || list.length === 0) {
          callback();
          return;
        }
        let loaded = 0;
        list.forEach((src) => {
          const a = new Audio();
          a.preload = "auto";
          a.loop = true;
          a.src = src;
          a.addEventListener(
            "canplaythrough",
            () => {
              loaded++;
              MUSIC.push(a);
              if (loaded === list.length) callback();
            },
            { once: true }
          );
          a.addEventListener(
            "error",
            () => {
              console.warn("[loadMusic] failed to load", src);
              loaded++;
              // не пушим нерабочий файл
              if (loaded === list.length) callback();
            },
            { once: true }
          );
        });
      }

      function stopMusic() {
        try {
          const mEl = document.getElementById("musicPlayer");
          if (mEl) {
            try {
              mEl.pause();
            } catch (e) {}
            // не сбрасываем currentTime, но оставляем скрытым
            // mEl.src = ""; // не делаем этого, чтобы продолжить резюме при старте
          }
          currentMusic = null;
        } catch (e) {}
      }

      function playLevelMusic(levelIndex) {
        const mEl = document.getElementById("musicPlayer");
        if (!mEl) return;
        const src =
          (MUSIC && MUSIC[levelIndex] && MUSIC[levelIndex].src) ||
          MUSIC_LIST[Math.min(levelIndex, MUSIC_LIST.length - 1)];
        if (!src) return;

        if (mEl.src && mEl.src.includes(src) && !mEl.paused) {
          mEl.volume = musicMuted ? 0 : musicVolume;
          mEl.loop = true;
          return;
        }

        try {
          mEl.pause();
        } catch (e) {}
        mEl.loop = true;
        mEl.src = src;
        mEl.currentTime = 0;
        mEl.preload = "auto";
        mEl.volume = musicMuted ? 0 : musicVolume;

        const p = mEl.play();
        if (p && typeof p.then === "function") {
          p.catch((err) => {
            console.warn("[playLevelMusic] play blocked", err);
          });
        }
        currentMusic = mEl;
      }

      // Воспроизводит случайный звук из SOUNDS[listName] с указанной громкостью (0..1)
      function playRandomSound(listName, volume = 1.0) {
        if (effectsMuted) return;
        const arr = SOUNDS[listName];
        if (!arr || arr.length === 0) return;
        const idx = Math.floor(Math.random() * arr.length);
        const srcAudio = arr[idx];
        if (!srcAudio) return;
        try {
          const a = srcAudio.cloneNode(true);
          a.volume = Math.max(0, Math.min(1, volume * effectsVolume));
          const p = a.play();
          if (p && typeof p.then === "function") {
            p.catch((err) => {
              console.warn("[playRandomSound] play blocked", err);
            });
          }
        } catch (e) {
          try {
            srcAudio.volume = Math.max(0, Math.min(1, volume * effectsVolume));
            srcAudio.play();
          } catch (e2) {}
        }
      }

      // удобные обёртки
      function playGoydaSound() {
        playRandomSound("goyda", 1.0);
      }
      function playAttackSound() {
        const arr = SOUNDS["attack"];
        if (!arr || arr.length === 0) return;

        // Если есть активный звуковой объект и он ещё играет — ускорим его
        if (
          currentAttackAudio &&
          !currentAttackAudio.paused &&
          !currentAttackAudio.ended
        ) {
          // защитимся от NaN или неинициализированного duration
          try {
            // если звук почти кончается, позволим ему дойти до конца и не ускорять
            if (
              currentAttackAudio.duration &&
              currentAttackAudio.currentTime <
                currentAttackAudio.duration - 0.06
            ) {
              currentAttackAudio.playbackRate = Math.min(
                attackMaxRate,
                (currentAttackAudio.playbackRate || 1) * attackAccelStep
              );
              // можно также слегка поднять громкость, но осторожно:
              // currentAttackAudio.volume = Math.min(1, currentAttackAudio.volume + 0.04);
              return;
            }
          } catch (e) {
            // fallthrough — если доступ к свойствам не разрешён (редкий кейс), начнём новый звук
          }
        }

        // Иначе начинаем новый экземпляр звука
        const idx = Math.floor(Math.random() * arr.length);
        const srcAudio = arr[idx];
        if (!srcAudio) return;
        try {
          const a = srcAudio.cloneNode(true);
          a.volume = attackBaseVolume * effectsVolume * (effectsMuted ? 0 : 1);

          a.playbackRate = 1.0;
          // при завершении — очищаем ссылку
          a.addEventListener(
            "ended",
            () => {
              if (currentAttackAudio === a) currentAttackAudio = null;
            },
            { once: true }
          );
          // на всякий случай очистим при ошибке
          a.addEventListener(
            "error",
            () => {
              if (currentAttackAudio === a) currentAttackAudio = null;
            },
            { once: true }
          );

          currentAttackAudio = a;
          const p = a.play();
          if (p && typeof p.then === "function") {
            p.catch(() => {
              // playback заблокирован/ошибка — просто сбросим ссылку
              if (currentAttackAudio === a) currentAttackAudio = null;
            });
          }
        } catch (err) {
          // fallback: попробовать проиграть исходный элемент (если он доступен)
          try {
            if (srcAudio) {
              srcAudio.volume = attackBaseVolume;
              srcAudio.playbackRate = 1;
              srcAudio.play();
            }
          } catch (e) {}
        }
      }
      function playHurtSound() {
        playRandomSound("hurt", 0.9);
      }

      /* =============================
   HELPERS (всё здесь)
   ============================= */
      const TILE = 40;
      function mapToPx(mx, my) {
        return { x: mx * TILE + TILE / 2, y: my * TILE + TILE / 2 };
      }
      function normalizeAngle(a) {
        while (a > Math.PI) a -= Math.PI * 2;
        while (a < -Math.PI) a += Math.PI * 2;
        return a;
      }
      function dist(a, b) {
        if (!a || !b) return 1e6;
        return Math.hypot(a.x - b.x, a.y - b.y);
      }
      // небольшая утилка — смешать hex-цветы: hexBlend("#334455", "#ffffff", 0.05)
      function hexToRgb(hex) {
        const h = hex.replace("#", "");
        const bigint = parseInt(
          h.length === 3
            ? h
                .split("")
                .map((c) => c + c)
                .join("")
            : h,
          16
        );
        return {
          r: (bigint >> 16) & 255,
          g: (bigint >> 8) & 255,
          b: bigint & 255,
        };
      }
      function rgbToHex(r, g, b) {
        return (
          "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)
        );
      }
      function hexBlend(aHex, bHex, t) {
        const a = hexToRgb(aHex),
          b = hexToRgb(bHex);
        const r = Math.round(a.r * (1 - t) + b.r * t);
        const g = Math.round(a.g * (1 - t) + b.g * t);
        const bl = Math.round(a.b * (1 - t) + b.b * t);
        return rgbToHex(r, g, bl);
      }

      // --- helper: rounded rect path and stroke ---
      function roundRect(ctx, x, y, w, h, r) {
        const rr = Math.max(0, Math.min(r, w / 2, h / 2));
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y, x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x, y + h, rr);
        ctx.arcTo(x, y + h, x, y, rr);
        ctx.arcTo(x, y, x + w, y, rr);
        ctx.closePath();
      }
      function roundRectStroke(ctx, x, y, w, h, r) {
        roundRect(ctx, x, y, w, h, r);
        ctx.stroke();
      }

      /* find nearest floor tile around (used to rescue stuck entities) */
      function findNearestFloorPx(mapData, x, y, maxRadius = 6) {
        const startMx = Math.floor(x / TILE),
          startMy = Math.floor(y / TILE);
        for (let r = 0; r <= maxRadius; r++) {
          for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
              const mx = startMx + dx,
                my = startMy + dy;
              if (
                my < 0 ||
                my >= mapData.raw.length ||
                mx < 0 ||
                mx >= mapData.raw[0].length
              )
                continue;
              if (mapData.raw[my][mx] === "." || mapData.raw[my][mx] === " ") {
                return mapToPx(mx, my);
              }
            }
          }
        }
        return null;
      }
      // -----------------------------
      // HELPERS for AI & LOS
      // -----------------------------

      // Проверяет, есть ли "линия видимости" между двумя точками (есть ли стена между ними).
      // Возвращает true если линия *пересекает* стену.
      function isLineBlocked(a, b) {
        if (!mapData || !mapData.raw) return false;
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const distTotal = Math.hypot(dx, dy);
        if (distTotal < 8) return false;
        const steps = Math.ceil(distTotal / 8); // шаг ~8px
        for (let i = 1; i < steps; i++) {
          const t = i / steps;
          const ix = a.x + dx * t;
          const iy = a.y + dy * t;
          if (isWallAtPx(ix, iy)) return true;
        }
        return false;
      }

      // Выбирает случайную достижимую цель (в пикселях) для блуждания врага.
      // Возвращает {x,y} или null.
      function pickWanderTarget(mapData, originX, originY, maxRadiusTiles = 6) {
        if (!mapData || !mapData.raw) return null;
        const startMx = Math.floor(originX / TILE);
        const startMy = Math.floor(originY / TILE);
        const candidates = [];
        for (let dy = -maxRadiusTiles; dy <= maxRadiusTiles; dy++) {
          for (let dx = -maxRadiusTiles; dx <= maxRadiusTiles; dx++) {
            const mx = startMx + dx;
            const my = startMy + dy;
            if (
              my < 0 ||
              my >= mapData.raw.length ||
              mx < 0 ||
              mx >= mapData.raw[0].length
            )
              continue;
            if (mapData.raw[my][mx] === "." || mapData.raw[my][mx] === " ") {
              candidates.push(mapToPx(mx, my));
            }
          }
        }
        if (candidates.length === 0) return null;
        // случайный выбор, с небольшим шансом предпочесть ближнюю
        return candidates[Math.floor(Math.random() * candidates.length)];
      }

      /* =============================
   MAPS
   ============================= */
      const MAPS = [
        [
          "############################",
          "#......#......##.....#....#",
          "#.####.#.####.##.##..#..#.#",
          "#.#.....#....#....#..#..#.#",
          "#.#.#####.##.######.##..#.#",
          "#.#.....#..#..........#..#",
          "#.#####.##.##########.#..#",
          "#.....#.....#......#..#..#",
          "###.#.#####.#.##.#.#..#..#",
          "#...#.....#...#..#......##",
          "#.#########.#.#######.##.#",
          "#...........#.........#..#",
          "############################",
        ],
        [
          "############################",
          "#......#......##.....#....#",
          "#.####.#.####.##.##..#..#.#",
          "#.#.....#....#....#..#..#.#",
          "#.#.#####.##.######.##..#.#",
          "#.#.....#..#..........#..#",
          "#.#####.##.##########.#..#",
          "#.....#.....#......#..#..#",
          "###.#.#####.#.##.#.#..#..#",
          "#...#.....#...#..#......##",
          "#.#########.#.#######.##.#",
          "#...........#.........#..#",
          "############################",
        ],
        [
          "############################",
          "#......#......##.....#....#",
          "#.####.#.####.##.##..#..#.#",
          "#.#.....#....#....#..#..#.#",
          "#.#.#####.##.######.##..#.#",
          "#.#.....#..#..........#..#",
          "#.#####.##.##########.#..#",
          "#.....#.....#......#..#..#",
          "###.#.#####.#.##.#.#..#..#",
          "#...#.....#...#..#......##",
          "#.#########.#.#######.##.#",
          "#...........#.........#..#",
          "############################",
        ],
      ];

      /* =============================
   GAME STATE
   ============================= */
      // DEBUG: включить визуальную подсветку и подробный лог в консоль
      let DEBUG_SHOW_TILES_AROUND_EXIT = true; // можно временно выключить (false)
      let DEBUG_VERBOSE = true; // больше логов

      let state = "idle";
      let prevState = null;
      let currentLevel = 0;
      let score = 0;
      let mapData = null;
      let enemies = [];
      let items = [];
      let lastTime = 0;
      let attackCooldown = 0,
        superCooldown = 0,
        flashSuper = 0;
      let exitPulse = 0; // для пульсации маркера выхода
      // камера (для сдвига отрисовки; только для рендера)
      let camX = 0;
      let camY = 0;
      let goydaTimer = 0; // сек
      let levelReady = false; // true когда уровень полностью построен и можно проверять "уровень пройден"
      // floating death shouts
      const DEATH_SHOUTS = [
        "За 1700 я бы мог тебе отсосать...",
        "Я... сало...",
        "СТРАНА 404...",
        "Похрюкай..!",
        "Подождать и на Добролюбова можно...*",
        "Я не диван, чтобы мягко выглядеть...",
        "Зачем я пошёл в РСО...",
        "Все мы добрые челы, позитивные...",
        "ЛЭЭЭ КУДА!",
        "Киси-киси, мяу-мяу, киси-киси-мяу-мяу-мяу",
      ];

      let floatingTexts = []; // { x, y, text, life, vy, alpha, size }

      /* player */
      let player = {
        x: 80,
        y: H / 2,
        r: 20,
        hp: BALANCE.playerMaxHP,
        mana: BALANCE.playerMaxMana,
        damage: BALANCE.baseDamage,
        speed: 160,
        facing: 0,
      };

      /* =============================
   COLLISIONS & MOVEMENT
   ============================= */
      // Заменить старую isWallAtPx на эту версию.
      // Разрешает проход (возвращает false), если точка лежит рядом с маркером выхода.
      // Это устраняет "невидимую стену" перед выходом, не ломая общую логику коллизий.

      // ===== Reachability helpers (BFS on tile grid) =====
      function isTileWalkable(mx, my) {
        if (!mapData || !mapData.raw) return false;
        if (
          my < 0 ||
          my >= mapData.raw.length ||
          mx < 0 ||
          mx >= mapData.raw[0].length
        )
          return false;
        return mapData.raw[my][mx] !== "#";
      }

      function findPathBFS(startMx, startMy, targetMx, targetMy) {
        // returns array of [mx,my] from start to target or null if no path
        if (!mapData || !mapData.raw) return null;
        const h = mapData.raw.length,
          w = mapData.raw[0].length;
        const q = [];
        const seen = new Array(h).fill(0).map(() => new Array(w).fill(false));
        const parent = new Array(h).fill(0).map(() => new Array(w).fill(null));
        q.push([startMx, startMy]);
        seen[startMy][startMx] = true;
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];
        while (q.length) {
          const [mx, my] = q.shift();
          if (mx === targetMx && my === targetMy) {
            // build path
            const path = [];
            let cur = [mx, my];
            while (cur) {
              path.push(cur);
              cur = parent[cur[1]][cur[0]];
            }
            return path.reverse();
          }
          for (const d of dirs) {
            const nx = mx + d[0],
              ny = my + d[1];
            if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
            if (seen[ny][nx]) continue;
            if (!isTileWalkable(nx, ny)) continue;
            seen[ny][nx] = true;
            parent[ny][nx] = [mx, my];
            q.push([nx, ny]);
          }
        }
        return null;
      }

      // Найти ближайшую плитку рядом с exit, которая достижима из игрока
      function adjustExitToReachable() {
        if (!mapData || !mapData.exit) return;
        const startMx = Math.floor(player.x / TILE),
          startMy = Math.floor(player.y / TILE);
        const exitMx = Math.floor(mapData.exit.x / TILE),
          exitMy = Math.floor(mapData.exit.y / TILE);

        // если сама цель достижима — ничего не делаем
        const path = findPathBFS(startMx, startMy, exitMx, exitMy);
        if (path) {
          console.log(
            "[adjustExitToReachable] exit is reachable, path length =",
            path.length
          );
          return; // ok
        }

        console.warn(
          "[adjustExitToReachable] exit NOT reachable; searching nearest reachable tile near exit"
        );

        // Поиск ближайшей проходной плитки в радиусе R от exit, сортируя по эвклидовой дистанции к exit
        const R = 6; // радиус в тайлах — подкорректируй при необходимости
        const candidates = [];
        for (let dy = -R; dy <= R; dy++) {
          for (let dx = -R; dx <= R; dx++) {
            const mx = exitMx + dx,
              my = exitMy + dy;
            if (
              mx < 0 ||
              my < 0 ||
              my >= mapData.raw.length ||
              mx >= mapData.raw[0].length
            )
              continue;
            if (!isTileWalkable(mx, my)) continue;
            // проверяем достижимость от игрока
            const p = findPathBFS(startMx, startMy, mx, my);
            if (p) {
              const distToExit = Math.hypot(dx, dy);
              candidates.push({ mx, my, pathLen: p.length, distToExit });
            }
          }
        }

        if (candidates.length === 0) {
          console.error(
            "[adjustExitToReachable] no reachable candidate tiles near exit — leave exit as is"
          );
          return;
        }

        // выберем лучший: минимальный pathLen, затем близость к exit
        candidates.sort((a, b) => {
          if (a.pathLen !== b.pathLen) return a.pathLen - b.pathLen;
          return a.distToExit - b.distToExit;
        });

        const best = candidates[0];
        mapData.exit = mapToPx(best.mx, best.my);
        console.log(
          "[adjustExitToReachable] moved exit to reachable tile",
          best.mx,
          best.my,
          "pathLen=",
          best.pathLen
        );
      }

      function isWallAtPx(x, y) {
        const mx = Math.floor(x / TILE),
          my = Math.floor(y / TILE);

        // Если нет карты — считаем, что это стена
        if (!mapData || !mapData.raw) return true;

        // Вне карты — стена
        if (
          my < 0 ||
          my >= mapData.raw.length ||
          mx < 0 ||
          mx >= mapData.raw[0].length
        )
          return true;

        // Если эта клетка реально стена — обычно true
        const isWall = mapData.raw[my][mx] === "#";

        // Если это не стена — всё ок
        if (!isWall) return false;

        // --- НО: если стена находится в непосредственной близости к выходу, разрешаем проход ---
        // это защищённый обход для случая "невидимой стены" непосредственно перед exit.
        if (mapData && mapData.exit) {
          const dx = x - mapData.exit.x;
          const dy = y - mapData.exit.y;
          const d = Math.hypot(dx, dy);
          // tolerance — в пикселях; 1.5 * TILE означает ~полторы клетки вокруг выхода
          const tolerance = TILE * 1.5;
          if (d <= tolerance) {
            // считаем, что в этой области стены можно пройти (возвращаем false)
            // (это лишь локальное ослабление коллизии вокруг выхода)
            return false;
          }
        }

        // Обычное поведение: стена
        return true;
      }

      // Проверяет, находится ли между точками a и b преграда (стена).
      // Возвращает true если линия между a и b пересекает стену.
      function isLineBlocked(a, b) {
        if (!mapData || !mapData.raw) return false;
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.hypot(dx, dy);
        if (dist === 0) return false;
        // шаг проверки — чем меньше, тем точнее; ~8 пикселей даёт хороший баланс
        const step = 8;
        const steps = Math.ceil(dist / step);
        for (let i = 1; i <= steps; i++) {
          const t = i / steps;
          const sx = a.x + dx * t;
          const sy = a.y + dy * t;
          if (isWallAtPx(sx, sy)) return true;
        }
        return false;
      }

      function movePlayerBy(dx, dy) {
        if (Math.abs(dx) > 0.001 || Math.abs(dy) > 0.001) {
          player.facing = Math.atan2(dy, dx);
        }
        const nx = player.x + dx;
        if (!isWallAtPx(nx, player.y)) player.x = nx;
        else {
          const tryX = player.x + Math.sign(dx) * 1;
          if (!isWallAtPx(tryX, player.y)) player.x = tryX;
        }
        const ny = player.y + dy;
        if (!isWallAtPx(player.x, ny)) player.y = ny;
        else {
          const tryY = player.y + Math.sign(dy) * 1;
          if (!isWallAtPx(player.x, tryY)) player.y = tryY;
        }

        // CLAMP to map bounds (not canvas). fallback to canvas if no mapData.
        const mapPixelW = mapData && mapData.w ? mapData.w * TILE : W;
        const mapPixelH = mapData && mapData.h ? mapData.h * TILE : H;
        const margin = 10;
        player.x = Math.max(margin, Math.min(mapPixelW - margin, player.x));
        player.y = Math.max(margin, Math.min(mapPixelH - margin, player.y));
      }

      function moveEnemy(en, vx, vy, dt) {
        // vx,vy ожидаются в px/sec
        const nx = en.x + vx * dt;
        const ny = en.y + vy * dt;

        if (!isWallAtPx(nx, en.y)) en.x = nx;
        else {
          const nx2 = en.x + Math.sign(vx || 0) * 1;
          if (!isWallAtPx(nx2, en.y)) en.x = nx2;
        }

        if (!isWallAtPx(en.x, ny)) en.y = ny;
        else {
          const ny2 = en.y + Math.sign(vy || 0) * 1;
          if (!isWallAtPx(en.x, ny2)) en.y = ny2;
        }

        // CLAMP to map bounds (instead of canvas). fallback to canvas if no mapData.
        const mapPixelW = mapData && mapData.w ? mapData.w * TILE : W;
        const mapPixelH = mapData && mapData.h ? mapData.h * TILE : H;
        const margin = 10;
        en.x = Math.max(margin, Math.min(mapPixelW - margin, en.x));
        en.y = Math.max(margin, Math.min(mapPixelH - margin, en.y));
      }

      function ensureEntityNotInsideWall(en, dt) {
        if (isWallAtPx(en.x, en.y)) {
          en._stuckTimer = (en._stuckTimer || 0) + dt;
          if (en._stuckTimer > 2.0) {
            const p = findNearestFloorPx(mapData, en.x, en.y, 8);
            if (p) {
              en.x = p.x;
              en.y = p.y;
              en._stuckTimer = 0;
            } else {
              en._dead = true;
            }
          }
        } else {
          en._stuckTimer = 0;
        }
      }

      /* =============================
   SPAWN / BUILD LEVEL
   ============================= */
      function randomItem(raw) {
        const h = raw.length,
          w = raw[0].length;
        for (let t = 0; t < 200; t++) {
          const rx = Math.floor(Math.random() * w),
            ry = Math.floor(Math.random() * h);
          if (raw[ry][rx] === "." || raw[ry][rx] === " ") {
            const pos = mapToPx(rx, ry);
            return {
              x: pos.x,
              y: pos.y,
              type: Math.random() < 0.5 ? "heart" : "mana",
              r: 12,
            };
          }
        }
        return null;
      }
      function buildLevel(levelIndex) {
        enemies = [];
        items = [];
        const raw = MAPS[levelIndex];
        const h = raw.length,
          w = raw[0].length;
        mapData = { raw, w, h };
        // --- assign wall variant index per wall tile (deterministic by coords) ---
        mapData.wallVariantIdx = new Array(h);
        for (let yy = 0; yy < h; yy++) {
          mapData.wallVariantIdx[yy] = new Array(w).fill(-1);
        }

        const variantCount = TEMP_WALL_KEYS.length;
        function pickVariantIndex(mx, my, count) {
          if (count <= 0) return -1;
          // простой детерминированный хеш по coord, стабильный между перерисовками
          let seed = (mx * 73856093) ^ (my * 19349663);
          seed = seed >>> 0; // положительное целое
          return seed % count;
        }

        for (let yy = 0; yy < h; yy++) {
          for (let xx = 0; xx < w; xx++) {
            if (raw[yy][xx] === "#") {
              // выберем индекс варианта (по координатам, детерминированно)
              mapData.wallVariantIdx[yy][xx] = pickVariantIndex(
                xx,
                yy,
                variantCount
              );
            } else {
              mapData.wallVariantIdx[yy][xx] = -1;
            }
          }
        }

        outer: for (let y = 1; y < h - 1; y++) {
          for (let x = 1; x < w - 1; x++) {
            if (raw[y][x] === "." || raw[y][x] === " ") {
              const p = mapToPx(x, y);
              player.x = p.x;
              player.y = p.y;
              break outer;
            }
          }
        }
        // взять настройки из LEVEL_CONFIG (с запасом на случай отсутствия)
        const cfg = LEVEL_CONFIG[levelIndex] || LEVEL_CONFIG[0];
        const enemyCount = cfg.enemyCount || 6;

        // === SPAWN ENEMIES (с контролем плотности и инициализацией ai.target) ===
        const spawnMinDist = levelIndex >= 2 ? 220 : 140; // для 3-го уровня дальше от игрока
        for (let i = 0; i < enemyCount; i++) {
          let tries = 0;
          while (tries < 600) {
            tries++;
            const rx = Math.floor(Math.random() * w),
              ry = Math.floor(Math.random() * h);
            if (raw[ry][rx] === "." || raw[ry][rx] === " ") {
              const pos = mapToPx(rx, ry);
              if (Math.hypot(pos.x - player.x, pos.y - player.y) < spawnMinDist)
                continue;
              const nearby = enemies.filter(
                (ee) => Math.hypot(ee.x - pos.x, ee.y - pos.y) < 96
              ).length;
              if (nearby >= 3) continue;
              // выберем начальную цель блуждания (fallback - немного смещённая точка)
              const initialTarget = pickWanderTarget(
                mapData,
                pos.x,
                pos.y,
                5
              ) || {
                x: pos.x + (Math.random() - 0.5) * 80,
                y: pos.y + (Math.random() - 0.5) * 80,
              };
              enemies.push({
                x: pos.x,
                y: pos.y,
                r: 18 + Math.random() * 8,
                hp: Math.floor(
                  (30 + levelIndex * 18 + Math.floor(Math.random() * 30)) *
                    (cfg.hpMult || 1)
                ),
                speed: Math.floor(
                  (40 + levelIndex * 10 + Math.random() * 30) *
                    (cfg.speedMult || 1)
                ),
                type: "grunt",
                _hitCooldown: 0,
                _stuckTimer: 0,
                ai: {
                  state: "wander",
                  target: initialTarget,
                  changeTimer: 1.0 + Math.random() * 2.0,
                },
              });
              break;
            }
          }
        }

        // === Преобразование некоторых грантов в боссов согласно правилам уровня ===
        let bossCount = 0;
        let bossHpMult = 1.4;
        let bossSpeedMult = 0.9;

        if (levelIndex === 0) {
          // на первом уровне — ровно 1 слабый босс
          bossCount = 1;
          bossHpMult = 1.15; // слегка сильнее обычного (не жёстко)
          bossSpeedMult = 0.9; // чуть медленнее — "босс слабее"
        } else if (levelIndex === 1) {
          // на втором — 1 или 2 босса
          bossCount = Math.random() < 0.5 ? 1 : 2;
          bossHpMult = 1.45; // сильнее, чем на первом
          bossSpeedMult = 1.05; // могут быть чуть шустрее
        } else {
          // уровень 2 — оставляем поведение прежним: иногда боссы через рандом (сохраним старое поведение)
          // но для совместимости можно оставить bossCount = 0 и полагаться на прежнюю логику (если она есть)
          bossCount = 0;
        }

        // Если bossCount > 0 — попробуем превратить случайные враги в боссов
        if (bossCount > 0 && enemies.length > 0) {
          // соберём список индексов, которые можно превратить (избегаем тех, кто уже слишком близко к игроку)
          const candidateIdx = enemies
            .map((e, idx) => ({ e, idx }))
            .filter((x) => Math.hypot(x.e.x - player.x, x.e.y - player.y) > 120) // не слишком близко к игроку
            .map((x) => x.idx);

          // перемешиваем кандидатов
          for (let i = candidateIdx.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [candidateIdx[i], candidateIdx[j]] = [
              candidateIdx[j],
              candidateIdx[i],
            ];
          }

          // выберем up to bossCount индексов и превратим их в боссов
          let placed = 0;
          for (let i = 0; i < candidateIdx.length && placed < bossCount; i++) {
            const idx = candidateIdx[i];
            const en = enemies[idx];
            if (!en) continue;
            en.type = "boss";
            en.hp = Math.floor(en.hp * bossHpMult) + 20; // добавим запас ХП
            en.r = Math.max(en.r, 26); // босс — крупнее
            en.speed = Math.max(20, Math.floor(en.speed * bossSpeedMult));
            placed++;
          }

          // если кандидатов недостаточно (очень редкий случай) — создаём боссов отдельно
          let extraTries = 0;
          while (placed < bossCount && extraTries < 200) {
            extraTries++;
            const rx = Math.floor(Math.random() * w),
              ry = Math.floor(Math.random() * h);
            if (raw[ry][rx] === "." || raw[ry][rx] === " ") {
              const pos = mapToPx(rx, ry);
              if (Math.hypot(pos.x - player.x, pos.y - player.y) < 160)
                continue;
              enemies.push({
                x: pos.x,
                y: pos.y,
                r: 28,
                hp: Math.floor(
                  (60 + Math.floor(Math.random() * 40)) * (bossHpMult || 1)
                ),
                speed: Math.floor(
                  (30 + Math.random() * 30) * (bossSpeedMult || 1)
                ),
                type: "boss",
                _hitCooldown: 0,
                _stuckTimer: 0,
              });
              placed++;
            }
          }
        }

        for (let i = 0; i < 4; i++) items.push(randomItem(raw));
        let exit = null;
        for (let y = h - 2; y > 0; y--) {
          for (let x = w - 2; x > 0; x--) {
            if (raw[y][x] === "." || raw[y][x] === " ") {
              exit = mapToPx(x, y);
              break;
            }
          }
          if (exit) break;
        }
        mapData.exit = exit;

        // Для levelIndex === 2: вернуть прежнее поведение — небольшая вероятность, что некоторые гранты станут боссами (≈18%)
        if (levelIndex === 2) {
          for (let i = 0; i < enemies.length; i++) {
            if (Math.random() < 0.18) {
              const en = enemies[i];
              if (
                en.type !== "boss" &&
                Math.hypot(en.x - player.x, en.y - player.y) > 120
              ) {
                en.type = "boss";
                en.hp = Math.floor(en.hp * 1.6) + 30;
                en.r = Math.max(en.r, 28);
                en.speed = Math.max(20, Math.floor(en.speed * 1.15));
              }
            }
          }
        }
        return mapData;
      }

      /* =============================
   INPUT
   ============================= */
      // =============================
      // INPUT (заменённая версия, предотвращаем прокрутку страницы)
      // =============================
      const keys = {};

      // Утилита: считать, что игра "активна" для клавиш, если state === playing/gotoExit
      function isGameInputActive() {
        // также разрешаем, если canvas в фокусе (пользователь кликнул в игровое поле)
        return (
          state === "playing" ||
          state === "gotoExit" ||
          document.activeElement === canvas
        );
      }

      window.addEventListener("keydown", (e) => {
        const keyLower = (e.key || "").toLowerCase();

        // клавиши, для которых обычно браузер скроллит страницу
        const scrollKeys = [
          " ",
          "space",
          "arrowup",
          "arrowdown",
          "arrowleft",
          "arrowright",
        ];

        // некоторые браузеры дают код в e.code, некоторые в e.key; проверим оба
        const codeLower = (e.code || "").toLowerCase();

        // если игра активна (или canvas в фокусе) — блокируем дефолт для стрелок и пробела
        if (
          isGameInputActive() &&
          (scrollKeys.includes(keyLower) || scrollKeys.includes(codeLower))
        ) {
          // предотвращаем прокрутку и другие браузерные эффекты
          e.preventDefault();
        }

        keys[keyLower] = true;
        if (e.code === "Space") keys["space"] = true;
        if (e.key === " ") keys["space"] = true;

        if (e.key === "Escape") {
          if (state === "dialog" || state === "upgrade") hideOverlay();
        }
      });

      window.addEventListener("keyup", (e) => {
        const k = (e.key || "").toLowerCase();
        keys[k] = false;
        if (e.code === "Space") keys["space"] = false;
      });

      /* =============================
   AUDIO
   ============================= */
      let audioCtx = null;
      function ensureAudio() {
        if (!audioCtx)
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      // Разрешить WebAudio/Audioplay по первому клику
      window.addEventListener(
        "pointerdown",
        function resumeAudioOnce() {
          try {
            if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
          } catch (e) {}
          // также разрешим проигрывание audio elements (браузер после клика позволит)
          window.removeEventListener("pointerdown", resumeAudioOnce);
        },
        { once: true }
      );

      function playBeep(freq, dur = 0.06, vol = 0.06) {
        ensureAudio();
        const o = audioCtx.createOscillator(),
          g = audioCtx.createGain();
        o.type = "sine";
        o.frequency.value = freq;
        g.gain.value = vol;
        o.connect(g);
        g.connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + dur);
      }
      function playSuper() {
        ensureAudio();
        const t0 = audioCtx.currentTime;
        const o1 = audioCtx.createOscillator(),
          o2 = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o1.type = "sawtooth";
        o2.type = "sine";
        o1.frequency.value = 220;
        o2.frequency.value = 330;
        g.gain.value = 0.14;
        o1.connect(g);
        o2.connect(g);
        g.connect(audioCtx.destination);
        o1.start(t0);
        o2.start(t0);
        o1.frequency.exponentialRampToValueAtTime(60, t0 + 0.5);
        o2.frequency.exponentialRampToValueAtTime(80, t0 + 0.5);
        g.gain.exponentialRampToValueAtTime(0.001, t0 + 0.72);
        o1.stop(t0 + 0.72);
        o2.stop(t0 + 0.72);
      }

      /* =============================
   COMBAT
   ============================= */
      function performMelee() {
        playAttackSound();
        enemies.forEach((en) => {
          const dx = en.x - player.x,
            dy = en.y - player.y;
          const ang = Math.atan2(dy, dx);
          const da = Math.abs(normalizeAngle(ang - player.facing));
          const closeEnough = dist(en, player) < player.r + 24;
          const inFront = da < 1.6 && dist(en, player) < player.r + 48;
          if (inFront || closeEnough) {
            // проверим, есть ли стена между игроком и врагом
            const blocked = isLineBlocked(player, en);
            const dmg = Math.floor(player.damage / (blocked ? 3 : 1)); // через стену — в 3 раза меньше
            en.hp -= dmg;
            const kb = 8;
            en.x += Math.cos(ang) * kb;
            en.y += Math.sin(ang) * kb;
          }
        });
      }

      function performSuper() {
        playSuper();
        playGoydaSound();
        goydaTimer = 0.9; // показываем 0.9 секунды в канвасе
        // оставляем старый DOM-всплеск, но он не обязателен — можно убрать DOM элемент

        flashSuper = 1.0;
        const goy = document.getElementById("goydaText");
        goy.classList.add("show");
        setTimeout(() => goy.classList.remove("show"), 700);
        enemies.forEach((en) => {
          const dx = en.x - player.x,
            dy = en.y - player.y;
          const d = Math.hypot(dx, dy);
          if (d > 160) return;
          const angleToEnemy = Math.atan2(dy, dx);
          const da = Math.abs(normalizeAngle(angleToEnemy - player.facing));
          if (da < 0.7) {
            en.hp -= BALANCE.superDamage;
            en._hitCooldown = 0.5;
          }
        });
      }

      /* =============================
   UI OVERLAYS
   ============================= */
      const overlayRoot = document.getElementById("overlayRoot");
      function showOverlay(html) {
        // запомним текущее состояние, чтобы при закрытии вернуть его назад
        prevState = state;
        console.log("[showOverlay] prevState =", prevState);
        overlayRoot.innerHTML = "";
        const wrap = document.createElement("div");
        wrap.className = "dialog";
        wrap.innerHTML = html;
        overlayRoot.style.display = "flex";
        overlayRoot.appendChild(wrap);
        state = "dialog";
        console.log('[showOverlay] state set to "dialog"');
      }

      function hideOverlay() {
        overlayRoot.style.display = "none";
        overlayRoot.innerHTML = "";

        // восстановим предыдущее состояние (если оно было)
        if (prevState !== null) {
          state = prevState;
          prevState = null;
        } else {
          // на всякий случай поставим логически
          state =
            enemies.length === 0 && mapData && mapData.exit
              ? "gotoExit"
              : "playing";
        }
        console.log(
          "[hideOverlay] restored state =",
          state,
          " (enemies=",
          enemies.length,
          ")"
        );

        // ВАЖНО: если мы вернулись в активное состояние — убедимся, что игровой цикл запущен
        if (state === "playing" || state === "gotoExit") {
          lastTime = performance.now(); // предотвратит большой dt на первом кадре
          requestAnimationFrame(loop); // перезапустим цикл, если он остановился
          console.log("[hideOverlay] requested animation frame to resume loop");
        }
      }

      function showUpgradeOptions(onPick) {
        const html = `<h3>Выбор награды</h3><div class="muted">Выбери один из трёх даров.</div>
    <div class="choices" id="choiceBox">
      <div class="choice" data-choice="hp">+20 к макс HP</div>
      <div class="choice" data-choice="dmg">+6 к урону</div>
      <div class="choice" data-choice="mana">+30 к мане</div>
    </div>`;
        showOverlay(html);

        // Повесим обработчик асинхронно, чтобы элемент точно вставился в DOM
        setTimeout(() => {
          const box = document.getElementById("choiceBox");
          if (!box) {
            console.warn("[upgrade] choiceBox not found");
            return;
          }
          box.addEventListener(
            "click",
            (e) => {
              const c = e.target.closest(".choice");
              if (!c) return;
              const val = c.dataset.choice;
              console.log("[upgrade] selected", val);

              // сначала скроем оверлей, затем с небольшой задержкой применим выбор
              hideOverlay();
              setTimeout(() => onPick(val), 80);
            },
            { once: true }
          );
        }, 0);
      }

      function showEnemyDialog(levelIndex, onContinue) {
        // имена / фразы по уровням — легко редактируются
        const enemyData = [
          {
            name: "Пороллоно | Управляет салом",
            taunt:
              "Ха! Ты думаешь, лысиною нас испугаешь? Мы... Сало...И... Пороллон...Ты... не... побeдишь...",
          },
          {
            name: "Ильинович | Черная упругая ass",
            taunt:
              "Ты победил меня, но жалеешь об этом...Ведь такая попка...Только у меня.. До встречи на сезоне...",
          },
          {
            name: "Блэк Фэйс | Враг в отражении ",
            taunt:
              "ГОЙДА побеждает всё. Теперь мне это ясно..",
          },
        ];

        // получаем имя и фразу (fallback если нет)
        const ed = enemyData[levelIndex] || {
          name: "Противник",
          taunt: "...",
        };

        // пытаемся взять картинку босса: сначала берём ключ из LEVEL_CONFIG (cfg.bossImage),
        // затем fallback на ASSETS.boss, IMAGES.boss и т.д.
        const cfg = LEVEL_CONFIG[levelIndex] || LEVEL_CONFIG[0];
        const possibleKeys = [
          cfg && cfg.bossImage,
          "boss",
          "enemy_boss",
          null,
        ].filter(Boolean);

        let imgSrc = null;
        for (const k of possibleKeys) {
          if (IMAGES[k] && IMAGES[k].src) {
            imgSrc = IMAGES[k].src;
            break;
          }
          // last resort: try ASSETS mapping (string path)
          if (ASSETS[k]) {
            imgSrc = ASSETS[k];
            break;
          }
        }

        // строим html диалога: картинка слева + имя/фраза справа + кнопка продолжить
        const imgClassExtra = levelIndex === 2 ? "no-crop" : ""; // level 3 (index 2) - не кропаем
        const imgHtml = imgSrc
          ? `<div class="enemy-img ${imgClassExtra}"><img src="${imgSrc}" alt="${ed.name}"></div>`
          : `<div class="enemy-img ${imgClassExtra}"></div>`;

        const html = `<div class="enemy-dialog">
    ${imgHtml}
    <div class="enemy-meta">
      <div class="enemy-name">${ed.name}</div>
      <div class="enemy-taunt">${ed.taunt}</div>
      <div style="margin-top:12px" class="center"><button class="btn" id="contBtn">Продолжить</button></div>
    </div>
  </div>`;

        showOverlay(html);

        // навешиваем обработчик на продожить
        const contBtn = document.getElementById("contBtn");
        if (contBtn) {
          contBtn.addEventListener(
            "click",
            () => {
              hideOverlay();
              // callback когда скрыли
              if (typeof onContinue === "function") onContinue();
            },
            { once: true }
          );
        } else {
          // если по какой-то причине кнопка не нашлась — всё равно продолжаем
          setTimeout(() => {
            hideOverlay();
            if (typeof onContinue === "function") onContinue();
          }, 100);
        }
      }

      function showEnd(title, text) {
        // play appropriate sound and stop music
        if (title === TEXTS.victoryTitle) {
          stopMusic();
          playRandomSound("victory", 1.0);
        } else if (title === TEXTS.gameOverTitle) {
          stopMusic();
          playRandomSound("defeat", 1.0);
        }

        // include "claim" only for victory
        const claimHtml =
          title === TEXTS.victoryTitle
            ? '<div class="choice" id="claim">Забрать подарок</div>'
            : "";

        const html = `<h3>${title}</h3><div class="muted" style="margin-top:6px">${text}</div>
  <div style="margin-top:12px" class="choices">
    <div class="choice" id="replay">Играть снова</div>
    ${claimHtml}
  </div>`;

        showOverlay(html);

        document.getElementById("replay").addEventListener(
          "click",
          () => {
            hideOverlay();
            startGame();
          },
          { once: true }
        );

        if (title === TEXTS.victoryTitle) {
          const claimBtn = document.getElementById("claim");
          if (claimBtn) {
            claimBtn.addEventListener(
              "click",
              () => {
                hideOverlay();
                alert(
                  'Поздравляю! Назови кодовую фразу "РСО - помойка" и получи свой 🎁'
                );
              },
              { once: true }
            );
          }
        }
      }

      /* =============================
   GAME FLOW
   ============================= */
      function startGame() {
        currentLevel = 0;
        score = 0;
        player.hp = BALANCE.playerMaxHP;
        player.mana = BALANCE.playerMaxMana;
        player.damage = BALANCE.baseDamage;
        state = "playing";

        // Загрузим базовые общие ассеты (потом startLevel загрузит level-specific)
        loadImages(ASSETS, () => {
          loadSounds(SOUND_LISTS, () => {
            loadMusic(MUSIC_LIST, () => {
              wireAudioControls();
              wireMusicPlayerUI();
              startLevel(currentLevel);
              lastTime = performance.now();
              requestAnimationFrame(loop);
            });
          });
        });
      }

      function startLevel(idx) {
        levelReady = false;
        // очистим предыдущие сущности (на всякий случай)
        enemies = [];
        items = [];

        // соберём ассеты: поверх общих ASSETS наложим level-specific
        const levelAssets = ASSETS_LEVEL[idx] || {};
        // начальный набор — базовые ассеты
        const assetsToLoad = Object.assign({}, ASSETS);

        // floor
        // --- apply level-specific assets ---
        // floor: добавляем и ключ 'floor' и 'floorFull' (рендер ждёт IMAGES.floorFull)
        if (levelAssets.floor) {
          assetsToLoad.floor = levelAssets.floor;
          assetsToLoad.floorFull = levelAssets.floor; // чтобы render() нашёл IMAGES.floorFull
        } else {
          delete assetsToLoad.floor;
          delete assetsToLoad.floorFull;
        }

        // wallVariants -> разворачиваем в ключи wallVar0, wallVar1...
        // Изменение: используем единый общий набор wallVariants для всех уровней (если он есть в ASSETS_LEVEL[0]),
        // иначе падаем на levelAssets.wallVariants (как раньше).
        TEMP_WALL_KEYS = [];
        // предпочитаем "shared" набор из ASSETS_LEVEL[0] (чтобы на всех уровнях были одинаковые картинки)
        const sharedWallArr = Array.isArray(
          ASSETS_LEVEL[0] && ASSETS_LEVEL[0].wallVariants
        )
          ? ASSETS_LEVEL[0].wallVariants
          : Array.isArray(levelAssets.wallVariants)
          ? levelAssets.wallVariants
          : [];

        if (Array.isArray(sharedWallArr) && sharedWallArr.length > 0) {
          sharedWallArr.forEach((src, i) => {
            const key = "wallVar" + i;
            assetsToLoad[key] = src;
            TEMP_WALL_KEYS.push(key);
          });
        } else {
          TEMP_WALL_KEYS = [];
        }

        // Подхватим любые другие level-specific ключи (player/enemy/boss с любыми суффиксами),
        // чтобы в IMAGES появились ключи типа "enemy_lvl2", "boss_lvl2", "player_lvl3" и т.п.
        for (const k in levelAssets) {
          if (!Object.prototype.hasOwnProperty.call(levelAssets, k)) continue;
          if (k === "floor" || k === "wallVariants") continue;
          // просто копируем путь под тем же ключом — render/LEVEL_CONFIG использует эти имена
          assetsToLoad[k] = levelAssets[k];
        }

        // загрузим (перезапишет IMAGES нужными картинками)
        loadImages(assetsToLoad, () => {
          // после загрузки — строим уровень
          buildLevel(idx);

          setTimeout(() => {
            levelReady = true;
          }, 80);
          // сброс боёв и визуалов
          attackCooldown = 0;
          superCooldown = 0;
          flashSuper = 0;
          // не объявляем exitPulse здесь — она глобальная
          state = "playing";

          // если хотим — можно сразу назначить player image из config (опционально)
          // const cfg = LEVEL_CONFIG[idx] || LEVEL_CONFIG[0];
          // if (IMAGES[cfg.playerImage]) { /* используем IMAGES[cfg.playerImage] в render вместо IMAGES.player */ }
          playLevelMusic(idx);
          // безопасно продолжим цикл
          lastTime = performance.now();
          requestAnimationFrame(loop);
        });
      }

      /* =============================
   MAIN LOOP
   ============================= */
      function loop(ts) {
        const dt = Math.min(
          0.05,
          ((ts || performance.now()) - lastTime) / 1000
        );
        lastTime = ts || performance.now();
        if (state === "playing" || state === "gotoExit") {
          update(dt);
          render();
          updateHUD();
        }
        if (state === "playing" || state === "gotoExit")
          requestAnimationFrame(loop);
      }

      /* =============================
   UPDATE
   ============================= */
      function update(dt) {
        let mx = 0,
          my = 0;
        if (keys["arrowup"] || keys["w"] || keys["ц"]) my -= 1;
        if (keys["arrowdown"] || keys["s"] || keys["ы"]) my += 1;
        if (keys["arrowleft"] || keys["a"] || keys["ф"]) mx -= 1;
        if (keys["arrowright"] || keys["d"] || keys["в"]) mx += 1;
        const len = Math.hypot(mx, my) || 1;
        movePlayerBy(
          (mx / len) * player.speed * dt,
          (my / len) * player.speed * dt
        );

        if ((keys[" "] || keys["space"]) && attackCooldown <= 0) {
          performMelee();
          attackCooldown = 0.28;
        }
        if (attackCooldown > 0) attackCooldown -= dt;

        if (
          (keys["e"] || keys["у"]) &&
          superCooldown <= 0 &&
          player.mana >= BALANCE.superCost
        ) {
          performSuper();
          player.mana -= BALANCE.superCost;
          superCooldown = 1.6;
        }
        if (superCooldown > 0) superCooldown -= dt;

        player.mana = Math.min(BALANCE.playerMaxMana, player.mana + 8 * dt);
        if (goydaTimer > 0) goydaTimer = Math.max(0, goydaTimer - dt);

        enemies.forEach((en) => {
          // ensure ai object
          if (!en.ai)
            en.ai = {
              state: "wander",
              target: null,
              changeTimer: Math.random() * 2 + 1,
            };

          const dxP = player.x - en.x;
          const dyP = player.y - en.y;
          const dToPlayer = Math.hypot(dxP, dyP) || 1;

          const chaseRadius = 180 + currentLevel * 20;
          const loseInterestRadius = chaseRadius * 1.15;

          // state transitions
          if (
            en.ai.state !== "chase" &&
            dToPlayer < chaseRadius &&
            !isLineBlocked(en, player)
          ) {
            en.ai.state = "chase";
          } else if (
            en.ai.state === "chase" &&
            dToPlayer > loseInterestRadius
          ) {
            en.ai.state = "wander";
            en.ai.target = null;
            en.ai.changeTimer = 0.6 + Math.random() * 1.4;
          }

          let vx = 0,
            vy = 0;

          if (en.ai.state === "chase") {
            // chase player with slight jitter
            en._jit = en._jit || Math.random() * 10;
            const jitterAngle =
              Math.sin((performance.now() / 1000) * 2 + en._jit) * 0.18;
            const ang = Math.atan2(dyP, dxP) + jitterAngle;
            vx = Math.cos(ang) * en.speed;
            vy = Math.sin(ang) * en.speed;
          } else {
            // wander
            en.ai.changeTimer -= dt;
            if (!en.ai.target || en.ai.changeTimer <= 0) {
              en.ai.target = pickWanderTarget(mapData, en.x, en.y, 5) || {
                x: en.x + (Math.random() - 0.5) * 80,
                y: en.y + (Math.random() - 0.5) * 80,
              };
              en.ai.changeTimer = 1.0 + Math.random() * 2.0;
            }
            const tx = en.ai.target.x,
              ty = en.ai.target.y;
            const ddx = tx - en.x,
              ddy = ty - en.y;
            const dd = Math.hypot(ddx, ddy) || 1;
            if (dd < 8) {
              en.ai.changeTimer = 0.05; // пометить смену цели на следующем шаге
            } else {
              vx = (ddx / dd) * en.speed * 0.85; // wander чуть медленнее
              vy = (ddy / dd) * en.speed * 0.85;
            }
          }
          // временный лог (после вставки и для отладки)

          // apply movement (vx,vy in px/sec; dt in sec)
          moveEnemy(en, vx, vy, dt);
          // if (DEBUG_VERBOSE && Math.random() < 0.02) {
          //   console.debug(
          //     "EN",
          //     en.type,
          //     "ai",
          //     en.ai && en.ai.state,
          //     "pos",
          //     Math.round(en.x),
          //     Math.round(en.y),
          //     "vx",
          //     vx.toFixed(1),
          //     "vy",
          //     vy.toFixed(1)
          //   );
          // }
          ensureEntityNotInsideWall(en, dt);

          // collision with player
          const minD = en.r + player.r - 6;
          if (dist(en, player) < minD) {
            if (!en._hitCooldown || en._hitCooldown <= 0) {
              player.hp -= 8 + (en.type === "boss" ? 10 : 0);
              en._hitCooldown = 0.8;
              playHurtSound();
            }
          }

          if (en._hitCooldown > 0) en._hitCooldown -= dt;

          if (en.hp <= 0) {
            if (!en._dead) en._dead = true;
            if (!en._counted) {
              score += en.type === "boss" ? 25 : 10;
              en._counted = true;
              try {
                playBeep(1200, 0.04, 0.05);
              } catch (e) {}
              const shout =
                DEATH_SHOUTS[Math.floor(Math.random() * DEATH_SHOUTS.length)];
              floatingTexts.push({
                x: en.x,
                y: en.y - (en.r || 18) - 6,
                text: shout,
                life: 1.2,
                vy: -36 - Math.random() * 16,
                alpha: 1,
                size: 18 + Math.floor(Math.random() * 6),
              });
            }
          }
        });

        enemies = enemies.filter((e) => !e._dead);

        for (let i = items.length - 1; i >= 0; i--) {
          const it = items[i];
          if (dist(it, player) < player.r + it.r) {
            if (it.type === "heart") {
              player.hp = Math.min(
                BALANCE.playerMaxHP,
                player.hp + BALANCE.heartHeal
              );
            } else if (it.type === "mana") {
              player.mana = Math.min(
                BALANCE.playerMaxMana,
                player.mana + BALANCE.manaRestore
              );
            }
            items.splice(i, 1);
            const pickupKey =
              it.type === "heart" ? "pickup_heart" : "pickup_mana";
            playRandomSound(pickupKey, 0.9);
          }
        }
        exitPulse += dt * 3.0; // регулируй скорость пульсации (3.0 — приятный темп)

        if (enemies.length === 0 && state === "playing" && levelReady) {
          console.log(
            "[LEVEL CLEAR] enemies === 0, setting state -> gotoExit; mapData.exit=",
            !!(mapData && mapData.exit)
          );
          state = "gotoExit";

          // Показываем инструкцию
          showOverlay(`<h3>Враг повержен</h3><div class="muted" style="margin-top:8px">${TEXTS.gotoExitText}</div>
    <div style="margin-top:12px" class="center"><button class="btn" id="okContinue">Понятно</button></div>`);
          // после state = 'gotoExit';
          adjustExitToReachable();

          // Надёжно повесим обработчик — элемент уже создан в showOverlay, но проверим существование
          setTimeout(() => {
            const okBtn = document.getElementById("okContinue");
            if (okBtn) {
              okBtn.addEventListener(
                "click",
                () => {
                  console.log("[okContinue] clicked");
                  hideOverlay();
                },
                { once: true }
              );
            } else {
              console.warn(
                "[okContinue] button not found in DOM after showOverlay"
              );
              // на всякий случай сразу восстановим состояние
              hideOverlay();
            }
          }, 0);
        }

        if (state === "gotoExit" && mapData && mapData.exit) {
          const ex = mapData.exit;
          if (Math.hypot(player.x - ex.x, player.y - ex.y) < 26) {
            state = "pending";
            showEnemyDialog(currentLevel, () => {
              showUpgradeOptions((choice) => {
                console.log("[upgrade] applying", choice);
                if (choice === "hp") {
                  BALANCE.playerMaxHP += 20;
                  player.hp = Math.min(BALANCE.playerMaxHP, player.hp + 20);
                }
                if (choice === "dmg") player.damage += 6;
                if (choice === "mana") {
                  BALANCE.playerMaxMana += 30;
                  player.mana = Math.min(
                    BALANCE.playerMaxMana,
                    player.mana + 30
                  );
                }

                // безопасно увеличиваем уровень и запускаем следующий уровень чуть позже
                currentLevel++;
                console.log("[upgrade] currentLevel now", currentLevel);

                setTimeout(() => {
                  if (currentLevel >= MAPS.length) {
                    state = "victory";
                    showEnd(TEXTS.victoryTitle, TEXTS.victoryText);
                  } else {
                    // пометим, что идёт загрузка/стартер (опционально)
                    state = "loading";
                    startLevel(currentLevel);
                  }
                }, 120);
              });
            });
          }
        }
        // --- update floating death texts ---
        for (let i = floatingTexts.length - 1; i >= 0; i--) {
          const ft = floatingTexts[i];
          ft.y += ft.vy * dt; // поднимается
          ft.life -= dt;
          ft.alpha = Math.max(0, ft.life / 1.2);
          // лёгкое смещение в стороны для органичности
          // ft.x += Math.sin((1 - ft.life) * 10) * 6 * dt;
          if (ft.life <= 0) floatingTexts.splice(i, 1);
        }

        if (player.hp <= 0 && state !== "gameover") {
          state = "gameover";
          showEnd(TEXTS.gameOverTitle, TEXTS.gameOverText);
        }
      }

      /* =============================
   RENDER
   ============================= */
      function render() {
        ctx.clearRect(0, 0, W, H);
        // --- Camera: center on player and clamp to map bounds ---
        if (mapData && mapData.w && mapData.h) {
          const mapPixelW = mapData.w * TILE;
          const mapPixelH = mapData.h * TILE;

          // центрируем камеру на игроке
          camX = Math.round(player.x - W / 2);
          camY = Math.round(player.y - H / 2);

          // ограничим, чтобы не показывать пустоту за краями карты
          camX = Math.max(0, Math.min(camX, Math.max(0, mapPixelW - W)));
          camY = Math.max(0, Math.min(camY, Math.max(0, mapPixelH - H)));
        } else {
          camX = 0;
          camY = 0;
        }
        ctx.save();
        // --- качественное сглаживание и защита от subpixel blur ---
        ctx.imageSmoothingEnabled = true; // включить сглаживание (если хотите пиксарт — поставьте false)
        try {
          ctx.imageSmoothingQuality = "high";
        } catch (e) {}
        // Переводим координаты в целые, чтобы избежать полупиксельного смазывания при масштабировании
        // (не округляем всю систему камеры — округляем конкретные drawImage ниже)

        ctx.translate(-camX, -camY);
        // --- Если есть полноразмерный пол — нарисуем его одним блоком (screen/world привязка через камеру) ---
        // --- FLOOR: спокойный однотонный / лёгкий градиент (лучше для глаз) ---
        if (mapData) {
          const mapPixelW = mapData.w * TILE;
          const mapPixelH = mapData.h * TILE;

          // палитра — выбери 1 из вариантов ниже (или добавь свои)
          const FLOOR_PALETTES = [
            { name: "Ocean deep", color: "#2b5f8a" }, // спокойный тёмно-голубой
            { name: "Muted teal", color: "#143239" }, // спокойный тёмно-зелёный
            { name: "Slate", color: "#1f2630" }, // графитовый, нейтральный
            { name: "Warm stone", color: "#2d2b26" }, // тёплый нейтральный
          ];
          // используем цвет для текущего уровня (безопасно: fallback на index 0)
          const pal =
            FLOOR_PALETTES[Math.min(currentLevel, FLOOR_PALETTES.length - 1)];
          const base = pal ? pal.color : "#071421";

          // draw base rect (world coords; canvas уже смещён ctx.translate(-camX,-camY))
          ctx.fillStyle = base;
          ctx.fillRect(0, 0, mapPixelW, mapPixelH);

          // лёгкий вертикальный градиент сверху->снизу (очень тонкий, чтобы не отвлекать)
          const grad = ctx.createLinearGradient(0, 0, 0, mapPixelH);
          // немного светлее вверху, чуть темнее внизу
          grad.addColorStop(0, hexBlend(base, "#ffffff", 0.04)); // +4% светлее
          grad.addColorStop(1, hexBlend(base, "#000000", 0.06)); // +6% темнее
          ctx.globalAlpha = 0.06; // очень тонкий эффект
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, mapPixelW, mapPixelH);
          ctx.globalAlpha = 1.0;

          // если есть floorFull — можем наложить его как паттерн с низкой непрозрачностью
          if (IMAGES.floorFull) {
            try {
              const p = ctx.createPattern(IMAGES.floorFull, "repeat");
              ctx.globalAlpha = 0.06; // едва заметная текстура
              ctx.fillStyle = p;
              ctx.fillRect(0, 0, mapPixelW, mapPixelH);
              ctx.globalAlpha = 1.0;
            } catch (e) {
              // ignore pattern errors
              ctx.globalAlpha = 1.0;
            }
          }
        }

        if (mapData && mapData.raw) {
          // shift drawing by camera
          function VIDX_OK(v) {
            return typeof v === "number" && v >= 0 && v < TEMP_WALL_KEYS.length;
          }
          const hasFullFloor = !!(IMAGES.floorFull || IMAGES.floor);
          for (let y = 0; y < mapData.raw.length; y++) {
            for (let x = 0; x < mapData.raw[y].length; x++) {
              const ch = mapData.raw[y][x];
              const px = x * TILE,
                py = y * TILE;
              if (ch === "#") {
                // --- outer frame (как раньше) ---
                ctx.fillStyle = "#071721";
                ctx.fillRect(px, py, TILE, TILE);
                ctx.fillStyle = "#082a2f";
                ctx.fillRect(px + 6, py + 6, TILE - 12, TILE - 12);

                // --- внутренняя картинка (если есть) --- (вставляем её внутрь "кубика")
                if (mapData && mapData.wallVariantIdx) {
                  const idx = mapData.wallVariantIdx[y][x];
                  if (typeof idx === "number") {
                    const key = `wallVar${idx}`;
                    const img = IMAGES[key];
                    if (img) {
                      // параметры отступов / скейла — можно подрегулировать
                      const innerPad = 8; // отступ внутри внутреннего квадрата
                      const sx = px + 6 + innerPad / 2;
                      const sy = py + 6 + innerPad / 2;
                      const sw = TILE - 12 - innerPad;
                      const sh = TILE - 12 - innerPad;

                      // Clip to rounded rect, затем рисуем изображение с "cover"-подходом
                      ctx.save();
                      roundRect(ctx, sx, sy, sw, sh, 6);
                      ctx.clip();

                      // "cover" fit: заполняем box, сохраняя пропорции и центрируя
                      const imgAR = img.width / img.height;
                      const boxAR = sw / sh;
                      if (imgAR > boxAR) {
                        // картинка шире коробки -> масштабируем по высоте
                        const dh = sh;
                        const dw = dh * imgAR;
                        const dx = sx - (dw - sw) / 2;
                        ctx.drawImage(img, dx, sy, dw, dh);
                      } else {
                        // картинка выше/уже -> масштабируем по ширине
                        const dw = sw;
                        const dh = dw / imgAR;
                        const dy = sy - (dh - sh) / 2;
                        ctx.drawImage(img, sx, dy, dw, dh);
                      }
                      ctx.restore();

                      // тенёк / внутренняя обводка для лучшей читаемости
                      ctx.save();
                      ctx.lineWidth = 2;
                      ctx.strokeStyle = "rgba(0,0,0,0.45)";
                      roundRectStroke(ctx, sx, sy, sw, sh, 6);
                      ctx.restore();
                    }
                  }
                }
              } else {
                // пол: рисуем тайловый пол только если нет полноразмерной текстуры/паттерна
                if (!hasFullFloor) {
                  ctx.fillStyle = "#5050a3";
                  ctx.fillRect(px, py, TILE, TILE);
                  ctx.fillStyle = "rgba(255,255,255,0.01)";
                  ctx.fillRect(px, py + TILE - 3, TILE, 1);
                } else {
                  // если текстура пола есть — не затираем её; рисуем лёгкую рамку тайла
                  // (рамка тонкая, чтобы не заглушать текстуру, можно настроить)
                  ctx.strokeStyle = "rgba(0,0,0,0.06)";
                  ctx.lineWidth = 1;
                  ctx.strokeRect(px + 1, py + 1, TILE - 2, TILE - 2);
                }
              }
            }
          }
          // draw pulsing exit marker (заменяет прежний прямоугольный маркер)
          if (mapData && mapData.exit) {
            const ex = mapData.exit;
            // пульсация (значение ~1.0..1.12)
            const pulse = 1 + 0.12 * Math.sin(exitPulse);

            // внешнее свечение (пульсирующее)
            ctx.save();
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#ffd76b";
            ctx.beginPath();
            ctx.arc(ex.x, ex.y, 18 * pulse, 0, Math.PI * 2);
            ctx.shadowColor = "rgba(255,215,107,0.9)";
            ctx.shadowBlur = 20;
            ctx.fill();
            ctx.restore();

            // внутренний яркий круг (основной маркер)
            ctx.beginPath();
            ctx.fillStyle = "#ffdb6b";
            ctx.arc(ex.x, ex.y, 10, 0, Math.PI * 2);
            ctx.fill();

            // маленькая тёмная метка/штрих (визуальный контраст)
            ctx.fillStyle = "#6b4512";
            ctx.fillRect(ex.x - 3, ex.y - 3, 6, 6);

            // подпись над маркером
            ctx.fillStyle = "#fff7e0";
            ctx.font = "13px Inter, sans-serif";
            ctx.textAlign = "center";
            // подпись слегка подпрыгивает вместе с пульсом
            ctx.fillText("ВЫХОД", ex.x, ex.y - 20 - 4 * (pulse - 1));
          }
        }

        items.forEach((it) => {
          if (IMAGES.heart && it.type === "heart")
            ctx.drawImage(IMAGES.heart, it.x - 16, it.y - 16, 32, 32);
          else if (IMAGES.mana && it.type === "mana")
            ctx.drawImage(IMAGES.mana, it.x - 16, it.y - 16, 32, 32);
          else {
            if (it.type === "heart") {
              ctx.fillStyle = "#ff6b6b";
              ctx.beginPath();
              ctx.arc(it.x, it.y, 10, 0, Math.PI * 2);
              ctx.fill();
            } else {
              ctx.fillStyle = "#4aa3ff";
              ctx.fillRect(it.x - 10, it.y - 10, 20, 20);
            }
          }
        });
        const cfg = LEVEL_CONFIG[currentLevel] || LEVEL_CONFIG[0];
        const gruntKey = cfg.enemyImage || "enemy1";
        const bossKey = cfg.bossImage || "boss";
        const playerKey = cfg.playerImage || "player";
        enemies.forEach((en) => {
          if (en.type === "grunt") {
            if (IMAGES[gruntKey])
              ctx.drawImage(IMAGES[gruntKey], en.x - 24, en.y - 24, 48, 48);
            else if (IMAGES.enemy1)
              ctx.drawImage(IMAGES.enemy1, en.x - 24, en.y - 24, 48, 48);
            else {
              /* fallback drawing */
            }
          } else {
            if (IMAGES[bossKey])
              ctx.drawImage(IMAGES[bossKey], en.x - 36, en.y - 36, 72, 72);
            else if (IMAGES.boss)
              ctx.drawImage(IMAGES.boss, en.x - 36, en.y - 36, 72, 72);
            else {
              /* fallback */
            }
          }
          ctx.fillStyle = "rgba(0,0,0,0.5)";
          ctx.fillRect(en.x - 20, en.y - en.r - 12, 40, 6);
          ctx.fillStyle = "#60d36b";
          const denom = 60 + currentLevel * 40;
          const w = (Math.max(0, en.hp) / denom) * 40;
          ctx.fillRect(en.x - 20, en.y - en.r - 12, Math.max(0, w), 6);
        });

        if (IMAGES[playerKey])
          ctx.drawImage(
            IMAGES[playerKey],
            player.x - 28,
            player.y - 28,
            56,
            56
          );
        else if (IMAGES.player)
          ctx.drawImage(IMAGES.player, player.x - 28, player.y - 28, 56, 56);

        floatingTexts.forEach((ft) => {
          ctx.save();
          ctx.globalAlpha = Math.min(1, ft.alpha);
          ctx.textAlign = "center";
          ctx.font = `${ft.size}px Inter, sans-serif`;
          // тонкая тень/обводка для читаемости
          ctx.lineWidth = 4;
          ctx.strokeStyle = "rgba(0,0,0,0.55)";
          ctx.fillStyle = "#ffd76b"; // цвет чуть похоже на GOYDA, но можно изменить
          ctx.strokeText(ft.text, ft.x, ft.y);
          ctx.fillText(ft.text, ft.x, ft.y);
          ctx.restore();
        });

        if (goydaTimer > 0) {
          ctx.save();

          const t = goydaTimer; // 0..0.9
          const alpha = Math.min(1, t * 1.6);
          const scale = 1 + 0.18 * (1 - t); // небольшой всплеск
          ctx.translate(player.x, player.y - 60);
          ctx.scale(scale, scale);
          ctx.globalAlpha = alpha;
          ctx.textAlign = "center";
          ctx.font = "46px Inter, sans-serif";
          ctx.fillStyle = "#ffd76b";
          ctx.lineWidth = 6;
          ctx.strokeStyle = "rgba(0,0,0,0.6)";
          ctx.strokeText("ГООООЙДА", 0, 0);
          ctx.fillText("ГООООЙДА", 0, 0);
          ctx.restore();
        }

        if (flashSuper > 0) {
          ctx.save();
          ctx.translate(player.x, player.y);
          ctx.rotate(player.facing);
          ctx.globalAlpha = Math.min(0.7, flashSuper);
          ctx.fillStyle = "rgba(217,180,74,0.32)";
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, 160, -0.7, 0.7);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
          flashSuper = Math.max(0, flashSuper - 0.06);
        }

        ctx.fillStyle = "#dbe9ff";
        ctx.font = "14px Inter, sans-serif";
        ctx.fillText(
          `HP: ${Math.max(0, Math.round(player.hp))} / ${BALANCE.playerMaxHP}`,
          12,
          18
        );
        ctx.fillText(
          `Mana: ${Math.max(0, Math.round(player.mana))} / ${
            BALANCE.playerMaxMana
          }`,
          12,
          36
        );
        ctx.restore();
      }
      function updateHUD() {
        const hpPerc = (Math.max(0, player.hp) / BALANCE.playerMaxHP) * 100;
        const manaPerc =
          (Math.max(0, player.mana) / BALANCE.playerMaxMana) * 100;
        document.getElementById("hpBar").style.width = hpPerc + "%";
        document.getElementById("manaBar").style.width = manaPerc + "%";
        document.getElementById("scoreText").textContent = "Очки: " + score;
        document.getElementById("levelText").textContent = `Уровень: ${
          currentLevel + 1
        } / 3`;
      }
      ctx.fillStyle = "#dbe9ff";
      ctx.font = "18px Inter";
      ctx.fillText('Нажми "Старт" чтобы начать испытание', W / 2 - 160, H / 2);
      updateHUD();
    </script>
  </body>
</html>
