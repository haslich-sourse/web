<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Stepan's Trial ‚Äî –ø–æ–¥–∞—Ä–æ–∫ (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ v3)</title>
    <style>
      :root {
        --bg: #071427;
        --card: #0b1520;
        --accent: #d9b44a;
        --muted: #9fb0bf;
        --hp: #ef3b3b;
        --mana: #4aa3ff;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: Inter, Segoe UI, Arial, sans-serif;
        background: linear-gradient(180deg, #071427 0%, #041018 100%);
        color: #e6eef6;
        -webkit-font-smoothing: antialiased;
      }
      .wrap {
        max-width: 1000px;
        margin: 22px auto;
        padding: 18px;
      }
      header {
        display: flex;
        gap: 14px;
        align-items: center;
      }
      .logo {
        width: 78px;
        height: 78px;
        border-radius: 14px;
        background: linear-gradient(135deg, var(--accent), #e36d6d);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 800;
        color: #071427;
        font-size: 22px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      }
      h1 {
        margin: 0;
        font-size: 22px;
      }
      .lead {
        color: var(--muted);
        margin-top: 6px;
        font-size: 14px;
      }
      .card {
        background: rgba(255, 255, 255, 0.03);
        padding: 16px;
        border-radius: 12px;
        margin-top: 16px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
      }
      .row {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .btn {
        background: var(--accent);
        border: none;
        padding: 10px 14px;
        border-radius: 10px;
        color: #081220;
        font-weight: 800;
        cursor: pointer;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.5);
      }
      .btn.secondary {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.06);
        color: var(--muted);
        font-weight: 700;
      }
      .muted {
        color: var(--muted);
        font-size: 13px;
      }
      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(2, 6, 10, 0.85);
        z-index: 70;
      }
      .modal.show {
        display: flex;
      }
      .modal img {
        max-width: 94vw;
        max-height: 92vh;
        border-radius: 8px;
        box-shadow: 0 18px 80px rgba(0, 0, 0, 0.7);
      }
      .modal .close {
        position: absolute;
        top: 18px;
        right: 18px;
        background: rgba(255, 255, 255, 0.06);
        border-radius: 8px;
        padding: 8px;
        color: #e6eef6;
        cursor: pointer;
      }
      #gameWrap {
        margin-top: 14px;
        display: flex;
        gap: 12px;
        align-items: flex-start;
      }
      canvas {
        background: transparent;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
        display: block;
      }
      #sidebar {
        width: 260px;
      }
      .hud {
        background: rgba(255, 255, 255, 0.02);
        padding: 10px;
        border-radius: 10px;
        font-size: 14px;
        color: var(--muted);
      }
      .bar {
        height: 12px;
        background: rgba(255, 255, 255, 0.04);
        border-radius: 8px;
        overflow: hidden;
        margin-top: 8px;
      }
      .center {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 80;
      }
      .dialog {
        background: linear-gradient(180deg, #071422, #081522);
        padding: 20px;
        border-radius: 12px;
        max-width: 720px;
        color: #dbe9ff;
        border: 1px solid rgba(255, 255, 255, 0.03);
      }
      .dialog h3 {
        margin: 0 0 8px 0;
      }
      .choices {
        display: flex;
        gap: 8px;
        margin-top: 10px;
        flex-wrap: wrap;
      }
      .choice {
        background: rgba(255, 255, 255, 0.03);
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        border: 1px solid rgba(255, 255, 255, 0.03);
      }
      .goyda {
        position: absolute;
        left: 50%;
        top: 20%;
        transform: translateX(-50%);
        font-size: 64px;
        font-weight: 900;
        color: #ffd76b;
        text-shadow: 0 6px 24px rgba(0, 0, 0, 0.6);
        pointer-events: none;
        z-index: 95;
        opacity: 0;
        transition: opacity 0.18s, transform 0.2s;
      }
      .goyda.show {
        opacity: 1;
        transform: translateX(-50%) scale(1.06);
      }
      footer {
        margin-top: 18px;
        color: var(--muted);
        font-size: 13px;
        text-align: center;
      }
      @media (max-width: 980px) {
        .wrap {
          padding: 12px;
        }
        #gameWrap {
          flex-direction: column;
        }
        #sidebar {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div class="logo">S21</div>
        <div>
          <h1>–î–æ—Å—Ç–æ–π–Ω—ã–π –ò—Å–ø—ã—Ç–∞–Ω–∏–µ ‚Äî –ü—É—Ç—å –°—Ç–µ–ø–∞–Ω–∞</h1>
          <div class="lead">
            –û—Ç–∫—Ä–æ–π –¥–≤–µ—Ä—å ‚Äî –∏ –Ω–∞—á–Ω—ë—Ç—Å—è —Ü–µ—Ä–µ–º–æ–Ω–∏—è. –≠—Ç–æ –Ω–µ –ø—Ä–æ—Å—Ç–æ –∏–≥—Ä–∞. –≠—Ç–æ ‚Äî
            –≤—ã–∑–æ–≤, –¥–∞–Ω—å —É–≤–∞–∂–µ–Ω–∏—è –ª—ã—Å–∏–Ω—ã –∏ —Ç–æ—Ä–∂–µ—Å—Ç–≤–æ –≤–∫—É—Å–∞.
          </div>
        </div>
      </header>

      <div class="card" id="introCard">
        <div id="introText" style="white-space: pre-wrap"></div>
        <div style="margin-top: 12px" class="row">
          <button class="btn" id="showEggBtn">–ü–æ–∫–∞–∑–∞—Ç—å —è–π—Ü–æ</button>
          <button class="btn" id="playBtnTop">–ò–≥—Ä–∞—Ç—å</button>
          <button class="btn secondary" id="downloadBtn">–°–∫–∞—á–∞—Ç—å (zip)</button>
        </div>
        <div style="margin-top: 10px" class="muted">
          –ö–Ω–æ–ø–∫–∞ ¬´–ü–æ–∫–∞–∑–∞—Ç—å —è–π—Ü–æ¬ª ‚Äî —à—É—Ç–∫–∞. –ù–∏–∫–∞–∫–∏—Ö –Ω–∞—Ä—É—à–µ–Ω–∏–π. –ü—Ä–æ—Å—Ç–æ –Ω–∞–∂–º–∏ –∏
          –ø–æ—Å–º–æ—Ç—Ä–∏.
        </div>
      </div>

      <div id="gameWrap">
        <canvas id="game" width="800" height="520"></canvas>
        <div id="sidebar">
          <div class="hud card">
            <div style="font-weight: 700">–°—Ç–µ–ø–∞–Ω ‚Äî –≥–µ—Ä–æ–π</div>
            <div style="margin-top: 8px">HP</div>
            <div class="bar">
              <i
                id="hpBar"
                style="
                  width: 100%;
                  background: var(--hp);
                  display: block;
                  height: 100%;
                "
              ></i>
            </div>
            <div style="margin-top: 8px">Mana</div>
            <div class="bar">
              <i
                id="manaBar"
                style="
                  width: 100%;
                  background: var(--mana);
                  display: block;
                  height: 100%;
                "
              ></i>
            </div>
            <div style="margin-top: 10px" class="muted">
              –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: WASD/—Å—Ç—Ä–µ–ª–∫–∏ ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ, –ø—Ä–æ–±–µ–ª ‚Äî —É–¥–∞—Ä, E ‚Äî –ì–û–û–û–û–ô–î–ê
              (—Å—É–ø–µ—Ä).
            </div>
            <div style="margin-top: 12px">
              <strong id="scoreText">–û—á–∫–∏: 0</strong>
            </div>
            <div style="margin-top: 8px" class="muted" id="levelText">
              –£—Ä–æ–≤–µ–Ω—å: 0 / 3
            </div>
            <div style="margin-top: 12px" class="center">
              <button class="btn" id="startBtn">–°—Ç–∞—Ä—Ç</button>
            </div>
          </div>

          <div style="height: 12px"></div>

          <div class="card hud" id="flavorCard">
            <div style="font-weight: 700">–ù–µ–±–æ–ª—å—à–∏–µ —Å–≤–µ—Ä—à–µ–Ω–∏—è</div>
            <div class="muted" style="margin-top: 8px" id="flavorText">
              –°—Ç–µ–ø–∞–Ω ‚Äî –ª—é–±–∏—Ç —Å–∞–ª–æ, –ö–∞–º—á–∞—Ç–∫—É, –î–æ—Ç—É –∏ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —è–π—Ü–∞. –ü–æ–∫–∞–∂–∏ —Å–≤–æ—é
              –ª—ã—Å—å ‚Äî –∏ –º–∏—Ä –ø—Ä–æ–≥–Ω—ë—Ç—Å—è.
            </div>
          </div>
        </div>
      </div>

      <footer>
        –ì–æ—Ç–æ–≤–æ ‚Äî –∑–∞–º–µ–Ω—è–π –∫–∞—Ä—Ç–∏–Ω–∫–∏ –≤ –ø–∞–ø–∫–µ <code>assets/</code> –∏ —Ç–µ–∫—Å—Ç—ã –≤
        –æ–±—ä–µ–∫—Ç–µ <code>TEXTS</code>.
      </footer>
    </div>

    <div class="modal" id="eggModal">
      <div class="close" id="eggClose">‚úï</div>
      <img id="eggImg" src="assets/egg_full.png" alt="egg" />
    </div>

    <div id="overlayRoot" class="overlay" style="display: none"></div>
    <div id="goydaText" class="goyda">–ì–û–û–û–û–ô–î–ê</div>

    <script>
      /* =============================
   CONFIG (—Ç–µ–∫—Å—Ç—ã / –ø—É—Ç–∏ / –±–∞–ª–∞–Ω—Å)
   –ú–µ–Ω—è–π —Ç—É—Ç: TEXTS, ASSETS, BALANCE
   ============================= */
      const TEXTS = {
        introLong: `–í–æ–∏—Å—Ç–∏–Ω—É, –≤ –¥–µ–Ω—å —Å–µ–π –º–∏—Ä –∑–∞–º–µ—Ç–∏—Ç —Å–≤–µ—Ç ‚Äî —Å–∏—è–Ω–∏–µ –ª—ã—Å–æ–π –≥–ª–∞–≤—ã –≤–µ–ª–∏–∫–æ–≥–æ –°—Ç–µ–ø–∞–Ω–∞. 
–°–µ–≥–æ–¥–Ω—è —Ç—ã –Ω–µ –ø—Ä–æ—Å—Ç–æ –æ—Ç–º–µ—á–∞–µ—à—å –¥–≤–∞–¥—Ü–∞—Ç—å –ø–µ—Ä–≤—ã–π –≥–æ–¥ ‚Äî —Å–µ–≥–æ–¥–Ω—è –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —ç–ø–æ–ø–µ—è.

–°—Ç–µ–ø–∞, —Å –î–†! –ù–æ —ç—Ç–æ –ª–∏—à—å –ø—Ä–µ–ª—é–¥–∏—è. –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å–≤–æ–π –¥–∞—Ä, –ø—Ä–µ–¥—Å—Ç–æ–∏—Ç –ø—Ä–æ–π—Ç–∏ –æ–±—Ä—è–¥:
–æ–∑–∞—Ä–∏—Ç—å –º–∏—Ä —Å–≤–µ—Ä–∫–∞–Ω–∏–µ–º —Å–≤–æ–µ–π –ª—ã—Å–∏–Ω—ã, –ø–æ–±–µ–¥–∏—Ç—å —Å–≤–∏—Ä–µ–ø–æ–µ –°–∞–ª–æ, –ø–æ–∫–∞–∑–∞—Ç—å —è–π—Ü–∞ –≤ –∑–Ω–∞–∫ –º—É–∂–µ—Å—Ç–≤–∞ –∏, –≤—ã–∫—Ä–∏–∫–Ω—É–≤ "–ì–û–û–û–û–ô–î–ê", –ø—Ä–æ–π—Ç–∏ —á–µ—Ä–µ–∑ –†—ã–±–Ω—É—é –õ–µ–Ω—Ç—É.

–¢–≤–æ—è –ª—ã—Å—å–∫–∞ ‚Äî —ç—Ç–æ —Ñ–∞–∫–µ–ª; —Ç–≤–æ—è —Å–º–µ–ª–æ—Å—Ç—å ‚Äî —â–∏—Ç. –ü—Ä–∏–≥–æ—Ç–æ–≤—å—Å—è: –∏—Å–ø—ã—Ç–∞–Ω–∏–µ –∂–¥—ë—Ç. –ò –ø–æ–º–Ω–∏ ‚Äî –≤—Å—ë —ç—Ç–æ —Ä–∞–¥–∏ —à—É—Ç–∫–∏, –¥—Ä—É–∂–±—ã –∏ —Å–∞–ª–∞.`,
        gotoExitText:
          "–í—Å–µ –≤—Ä–∞–≥–∏ –ø–æ–≤–µ—Ä–∂–µ–Ω—ã! –¢–µ–ø–µ—Ä—å –¥–æ–±–µ—Ä–∏—Å—å –¥–æ –≤—ã—Ö–æ–¥–∞ (–∂—ë–ª—Ç–∞—è –º–µ—Ç–∫–∞) –∏ –≤–æ–∑–∑–æ–≤–∏ –∫ –ª—ã—Å–∫–µ.",
        victoryTitle: "–ü–æ–±–µ–¥–∞!",
        victoryText:
          "–°—Ç–µ–ø–∞–Ω, —Ç—ã –ø—Ä–æ—à—ë–ª –≤—Å–µ –∏—Å–ø—ã—Ç–∞–Ω–∏—è. –í–æ–∑—å–º–∏ —Å–≤–æ–π –ø–æ–¥–∞—Ä–æ–∫ ‚Äî –æ–Ω –∑–∞—Å–ª—É–∂–µ–Ω.",
        gameOverTitle: "–ü–æ—Ä–∞–∂–µ–Ω–∏–µ",
        gameOverText:
          "–ù–µ –ø–µ—á–∞–ª—å—Å—è ‚Äî –ø–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞, –∏ –ø—É—Å—Ç—å –ª—ã—Å–∏–Ω—ã —Å–≤–µ—Ç –≤–Ω–æ–≤—å –≤–µ–¥—ë—Ç —Ç–µ–±—è.",
      };

      const ASSETS = {
        player: "assets/player.png",
        enemy1: "assets/enemy1.png",
        boss: "assets/enemy_boss.png",
        heart: "assets/heart.png",
        mana: "assets/mana.png",
        egg: "assets/egg_full.png",
      };

      const BALANCE = {
        playerMaxHP: 100,
        playerMaxMana: 100,
        baseDamage: 20,
        superCost: 40,
        superDamage: 120,
        heartHeal: 25,
        manaRestore: 40,
      };

      /* =============================
   BASICS
   ============================= */
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const W = canvas.width,
        H = canvas.height;
      document.getElementById("introText").textContent = TEXTS.introLong;
      document.getElementById("showEggBtn").addEventListener("click", () => {
        showEggModal();
      });
      document.getElementById("eggClose").addEventListener("click", () => {
        hideEggModal();
      });
      document.getElementById("playBtnTop").addEventListener("click", () => {
        startGame();
      });
      document.getElementById("startBtn").addEventListener("click", () => {
        startGame();
      });
      document.getElementById("downloadBtn").addEventListener("click", () => {
        alert(
          "–°–æ–±–µ—Ä–∏ –ø–∞–ø–∫—É: index.html + assets/ –∏ –∑–∞–ø–∞–∫—É–π; –Ω–∞–ø–∏—à–∏ –µ—Å–ª–∏ –Ω—É–∂–µ–Ω —Å–∫—Ä–∏–ø—Ç."
        );
      });
      function showEggModal() {
        const m = document.getElementById("eggModal");
        document.getElementById("eggImg").src = ASSETS.egg;
        m.classList.add("show");
      }
      function hideEggModal() {
        document.getElementById("eggModal").classList.remove("show");
      }

      /* =============================
   IMAGE LOADER
   ============================= */
      const IMAGES = {};
      function loadImages(list, callback) {
        const keys = Object.keys(list);
        let loaded = 0;
        if (keys.length === 0) {
          callback();
          return;
        }
        keys.forEach((k) => {
          const img = new Image();
          img.src = list[k];
          img.onload = () => {
            IMAGES[k] = img;
            if (++loaded === keys.length) callback();
          };
          img.onerror = () => {
            IMAGES[k] = null;
            if (++loaded === keys.length) callback();
          };
        });
      }

      /* =============================
   HELPERS (–≤—Å—ë –∑–¥–µ—Å—å)
   ============================= */
      const TILE = 40;
      function mapToPx(mx, my) {
        return { x: mx * TILE + TILE / 2, y: my * TILE + TILE / 2 };
      }
      function normalizeAngle(a) {
        while (a > Math.PI) a -= Math.PI * 2;
        while (a < -Math.PI) a += Math.PI * 2;
        return a;
      }
      function dist(a, b) {
        if (!a || !b) return 1e6;
        return Math.hypot(a.x - b.x, a.y - b.y);
      }

      /* find nearest floor tile around (used to rescue stuck entities) */
      function findNearestFloorPx(mapData, x, y, maxRadius = 6) {
        const startMx = Math.floor(x / TILE),
          startMy = Math.floor(y / TILE);
        for (let r = 0; r <= maxRadius; r++) {
          for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
              const mx = startMx + dx,
                my = startMy + dy;
              if (
                my < 0 ||
                my >= mapData.raw.length ||
                mx < 0 ||
                mx >= mapData.raw[0].length
              )
                continue;
              if (mapData.raw[my][mx] === "." || mapData.raw[my][mx] === " ") {
                return mapToPx(mx, my);
              }
            }
          }
        }
        return null;
      }

      /* =============================
   MAPS
   ============================= */
      const MAPS = [
        [
          "############################",
          "#......#......##.....#....#",
          "#.####.#.####.##.##..#..#.#",
          "#.#.....#....#....#..#..#.#",
          "#.#.#####.##.######.##..#.#",
          "#.#.....#..#..........#..#",
          "#.#####.##.##########.#..#",
          "#.....#.....#......#..#..#",
          "###.#.#####.#.##.#.#..#..#",
          "#...#.....#...#..#......##",
          "#.#########.#.#######.##.#",
          "#...........#.........#..#",
          "############################",
        ],
        [
          "############################",
          "#......#.....#.....#......#",
          "#.####.#.###.#.###.#.####.#",
          "#.#....#...#.#...#.#....#.#",
          "#.#.######.#.###.#.####.#.#",
          "#.#......#.#.....#......#.#",
          "#.######.#.#####.######.#.#",
          "#......#.#.......#......#.#",
          "####.#.#.#######.#.##.#.#.#",
          "#....#...#.....#...#..#...#",
          "#.#########.###.#####.####",
          "#...........#.........#..#",
          "############################",
        ],
        [
          "############################",
          "#..........#.............#.",
          "#.######.#.####.######.#.#.",
          "#.#....#.#....#.#....#.#.#.",
          "#.#.##.#.##.##.#.##.#.#.#.#",
          "#.#..#.#......#.#..#.#...#.",
          "#.##.#.########.#.##.###.#.",
          "#....#....#.....#.......#.#",
          "###.####.#.#####.#####.#.##",
          "#......#.#.....#.......#..#",
          "#.####.#.#####.#######.##.#",
          "#......#.........#.......#",
          "############################",
        ],
      ];

      /* =============================
   GAME STATE
   ============================= */
      // DEBUG: –≤–∫–ª—é—á–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—É—é –ø–æ–¥—Å–≤–µ—Ç–∫—É –∏ –ø–æ–¥—Ä–æ–±–Ω—ã–π –ª–æ–≥ –≤ –∫–æ–Ω—Å–æ–ª—å
      let DEBUG_SHOW_TILES_AROUND_EXIT = true; // –º–æ–∂–Ω–æ –≤—Ä–µ–º–µ–Ω–Ω–æ –≤—ã–∫–ª—é—á–∏—Ç—å (false)
      let DEBUG_VERBOSE = true; // –±–æ–ª—å—à–µ –ª–æ–≥–æ–≤

      let state = "idle";
      let prevState = null;
      let currentLevel = 0;
      let score = 0;
      let mapData = null;
      let enemies = [];
      let items = [];
      let lastTime = 0;
      let attackCooldown = 0,
        superCooldown = 0,
        flashSuper = 0;
      let exitPulse = 0; // –¥–ª—è –ø—É–ª—å—Å–∞—Ü–∏–∏ –º–∞—Ä–∫–µ—Ä–∞ –≤—ã—Ö–æ–¥–∞
      // –∫–∞–º–µ—Ä–∞ (–¥–ª—è —Å–¥–≤–∏–≥–∞ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏; —Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∞)
      let camX = 0;
      let camY = 0;

      /* player */
      let player = {
        x: 80,
        y: H / 2,
        r: 20,
        hp: BALANCE.playerMaxHP,
        mana: BALANCE.playerMaxMana,
        damage: BALANCE.baseDamage,
        speed: 160,
        facing: 0,
      };

      /* =============================
   COLLISIONS & MOVEMENT
   ============================= */
      // –ó–∞–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ä—É—é isWallAtPx –Ω–∞ —ç—Ç—É –≤–µ—Ä—Å–∏—é.
      // –†–∞–∑—Ä–µ—à–∞–µ—Ç –ø—Ä–æ—Ö–æ–¥ (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç false), –µ—Å–ª–∏ —Ç–æ—á–∫–∞ –ª–µ–∂–∏—Ç —Ä—è–¥–æ–º —Å –º–∞—Ä–∫–µ—Ä–æ–º –≤—ã—Ö–æ–¥–∞.
      // –≠—Ç–æ —É—Å—Ç—Ä–∞–Ω—è–µ—Ç "–Ω–µ–≤–∏–¥–∏–º—É—é —Å—Ç–µ–Ω—É" –ø–µ—Ä–µ–¥ –≤—ã—Ö–æ–¥–æ–º, –Ω–µ –ª–æ–º–∞—è –æ–±—â—É—é –ª–æ–≥–∏–∫—É –∫–æ–ª–ª–∏–∑–∏–π.

      // ===== Reachability helpers (BFS on tile grid) =====
      function isTileWalkable(mx, my) {
        if (!mapData || !mapData.raw) return false;
        if (
          my < 0 ||
          my >= mapData.raw.length ||
          mx < 0 ||
          mx >= mapData.raw[0].length
        )
          return false;
        return mapData.raw[my][mx] !== "#";
      }

      function findPathBFS(startMx, startMy, targetMx, targetMy) {
        // returns array of [mx,my] from start to target or null if no path
        if (!mapData || !mapData.raw) return null;
        const h = mapData.raw.length,
          w = mapData.raw[0].length;
        const q = [];
        const seen = new Array(h).fill(0).map(() => new Array(w).fill(false));
        const parent = new Array(h).fill(0).map(() => new Array(w).fill(null));
        q.push([startMx, startMy]);
        seen[startMy][startMx] = true;
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1],
        ];
        while (q.length) {
          const [mx, my] = q.shift();
          if (mx === targetMx && my === targetMy) {
            // build path
            const path = [];
            let cur = [mx, my];
            while (cur) {
              path.push(cur);
              cur = parent[cur[1]][cur[0]];
            }
            return path.reverse();
          }
          for (const d of dirs) {
            const nx = mx + d[0],
              ny = my + d[1];
            if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
            if (seen[ny][nx]) continue;
            if (!isTileWalkable(nx, ny)) continue;
            seen[ny][nx] = true;
            parent[ny][nx] = [mx, my];
            q.push([nx, ny]);
          }
        }
        return null;
      }

      // –ù–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à—É—é –ø–ª–∏—Ç–∫—É —Ä—è–¥–æ–º —Å exit, –∫–æ—Ç–æ—Ä–∞—è –¥–æ—Å—Ç–∏–∂–∏–º–∞ –∏–∑ –∏–≥—Ä–æ–∫–∞
      function adjustExitToReachable() {
        if (!mapData || !mapData.exit) return;
        const startMx = Math.floor(player.x / TILE),
          startMy = Math.floor(player.y / TILE);
        const exitMx = Math.floor(mapData.exit.x / TILE),
          exitMy = Math.floor(mapData.exit.y / TILE);

        // –µ—Å–ª–∏ —Å–∞–º–∞ —Ü–µ–ª—å –¥–æ—Å—Ç–∏–∂–∏–º–∞ ‚Äî –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
        const path = findPathBFS(startMx, startMy, exitMx, exitMy);
        if (path) {
          console.log(
            "[adjustExitToReachable] exit is reachable, path length =",
            path.length
          );
          return; // ok
        }

        console.warn(
          "[adjustExitToReachable] exit NOT reachable; searching nearest reachable tile near exit"
        );

        // –ü–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–µ–π –ø—Ä–æ—Ö–æ–¥–Ω–æ–π –ø–ª–∏—Ç–∫–∏ –≤ —Ä–∞–¥–∏—É—Å–µ R –æ—Ç exit, —Å–æ—Ä—Ç–∏—Ä—É—è –ø–æ —ç–≤–∫–ª–∏–¥–æ–≤–æ–π –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏ –∫ exit
        const R = 6; // —Ä–∞–¥–∏—É—Å –≤ —Ç–∞–π–ª–∞—Ö ‚Äî –ø–æ–¥–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–π –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
        const candidates = [];
        for (let dy = -R; dy <= R; dy++) {
          for (let dx = -R; dx <= R; dx++) {
            const mx = exitMx + dx,
              my = exitMy + dy;
            if (
              mx < 0 ||
              my < 0 ||
              my >= mapData.raw.length ||
              mx >= mapData.raw[0].length
            )
              continue;
            if (!isTileWalkable(mx, my)) continue;
            // –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∏–∂–∏–º–æ—Å—Ç—å –æ—Ç –∏–≥—Ä–æ–∫–∞
            const p = findPathBFS(startMx, startMy, mx, my);
            if (p) {
              const distToExit = Math.hypot(dx, dy);
              candidates.push({ mx, my, pathLen: p.length, distToExit });
            }
          }
        }

        if (candidates.length === 0) {
          console.error(
            "[adjustExitToReachable] no reachable candidate tiles near exit ‚Äî leave exit as is"
          );
          return;
        }

        // –≤—ã–±–µ—Ä–µ–º –ª—É—á—à–∏–π: –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π pathLen, –∑–∞—Ç–µ–º –±–ª–∏–∑–æ—Å—Ç—å –∫ exit
        candidates.sort((a, b) => {
          if (a.pathLen !== b.pathLen) return a.pathLen - b.pathLen;
          return a.distToExit - b.distToExit;
        });

        const best = candidates[0];
        mapData.exit = mapToPx(best.mx, best.my);
        console.log(
          "[adjustExitToReachable] moved exit to reachable tile",
          best.mx,
          best.my,
          "pathLen=",
          best.pathLen
        );
      }

      function isWallAtPx(x, y) {
        const mx = Math.floor(x / TILE),
          my = Math.floor(y / TILE);

        // –ï—Å–ª–∏ –Ω–µ—Ç –∫–∞—Ä—Ç—ã ‚Äî —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ —ç—Ç–æ —Å—Ç–µ–Ω–∞
        if (!mapData || !mapData.raw) return true;

        // –í–Ω–µ –∫–∞—Ä—Ç—ã ‚Äî —Å—Ç–µ–Ω–∞
        if (
          my < 0 ||
          my >= mapData.raw.length ||
          mx < 0 ||
          mx >= mapData.raw[0].length
        )
          return true;

        // –ï—Å–ª–∏ —ç—Ç–∞ –∫–ª–µ—Ç–∫–∞ —Ä–µ–∞–ª—å–Ω–æ —Å—Ç–µ–Ω–∞ ‚Äî –æ–±—ã—á–Ω–æ true
        const isWall = mapData.raw[my][mx] === "#";

        // –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —Å—Ç–µ–Ω–∞ ‚Äî –≤—Å—ë –æ–∫
        if (!isWall) return false;

        // --- –ù–û: –µ—Å–ª–∏ —Å—Ç–µ–Ω–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ–π –±–ª–∏–∑–æ—Å—Ç–∏ –∫ –≤—ã—Ö–æ–¥—É, —Ä–∞–∑—Ä–µ—à–∞–µ–º –ø—Ä–æ—Ö–æ–¥ ---
        // —ç—Ç–æ –∑–∞—â–∏—â—ë–Ω–Ω—ã–π –æ–±—Ö–æ–¥ –¥–ª—è —Å–ª—É—á–∞—è "–Ω–µ–≤–∏–¥–∏–º–æ–π —Å—Ç–µ–Ω—ã" –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –ø–µ—Ä–µ–¥ exit.
        if (mapData && mapData.exit) {
          const dx = x - mapData.exit.x;
          const dy = y - mapData.exit.y;
          const d = Math.hypot(dx, dy);
          // tolerance ‚Äî –≤ –ø–∏–∫—Å–µ–ª—è—Ö; 1.5 * TILE –æ–∑–Ω–∞—á–∞–µ—Ç ~–ø–æ–ª—Ç–æ—Ä—ã –∫–ª–µ—Ç–∫–∏ –≤–æ–∫—Ä—É–≥ –≤—ã—Ö–æ–¥–∞
          const tolerance = TILE * 1.5;
          if (d <= tolerance) {
            // —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ –≤ —ç—Ç–æ–π –æ–±–ª–∞—Å—Ç–∏ —Å—Ç–µ–Ω—ã –º–æ–∂–Ω–æ –ø—Ä–æ–π—Ç–∏ (–≤–æ–∑–≤—Ä–∞—â–∞–µ–º false)
            // (—ç—Ç–æ –ª–∏—à—å –ª–æ–∫–∞–ª—å–Ω–æ–µ –æ—Å–ª–∞–±–ª–µ–Ω–∏–µ –∫–æ–ª–ª–∏–∑–∏–∏ –≤–æ–∫—Ä—É–≥ –≤—ã—Ö–æ–¥–∞)
            return false;
          }
        }

        // –û–±—ã—á–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ: —Å—Ç–µ–Ω–∞
        return true;
      }

      function movePlayerBy(dx, dy) {
        if (Math.abs(dx) > 0.001 || Math.abs(dy) > 0.001) {
          player.facing = Math.atan2(dy, dx);
        }
        const nx = player.x + dx;
        if (!isWallAtPx(nx, player.y)) player.x = nx;
        else {
          const tryX = player.x + Math.sign(dx) * 1;
          if (!isWallAtPx(tryX, player.y)) player.x = tryX;
        }
        const ny = player.y + dy;
        if (!isWallAtPx(player.x, ny)) player.y = ny;
        else {
          const tryY = player.y + Math.sign(dy) * 1;
          if (!isWallAtPx(player.x, tryY)) player.y = tryY;
        }
        player.x = Math.max(10, Math.min(W - 10, player.x));
        player.y = Math.max(10, Math.min(H - 10, player.y));
      }
      function moveEnemy(en, vx, vy, dt) {
        const nx = en.x + vx * dt,
          ny = en.y + vy * dt;
        if (!isWallAtPx(nx, en.y)) en.x = nx;
        else {
          const nx2 = en.x + Math.sign(vx) * 1;
          if (!isWallAtPx(nx2, en.y)) en.x = nx2;
        }
        if (!isWallAtPx(en.x, ny)) en.y = ny;
        else {
          const ny2 = en.y + Math.sign(vy) * 1;
          if (!isWallAtPx(en.x, ny2)) en.y = ny2;
        }
        en.x = Math.max(10, Math.min(W - 10, en.x));
        en.y = Math.max(10, Math.min(H - 10, en.y));
      }
      function ensureEntityNotInsideWall(en, dt) {
        if (isWallAtPx(en.x, en.y)) {
          en._stuckTimer = (en._stuckTimer || 0) + dt;
          if (en._stuckTimer > 2.0) {
            const p = findNearestFloorPx(mapData, en.x, en.y, 8);
            if (p) {
              en.x = p.x;
              en.y = p.y;
              en._stuckTimer = 0;
            } else {
              en._dead = true;
            }
          }
        } else {
          en._stuckTimer = 0;
        }
      }

      /* =============================
   SPAWN / BUILD LEVEL
   ============================= */
      function randomItem(raw) {
        const h = raw.length,
          w = raw[0].length;
        for (let t = 0; t < 200; t++) {
          const rx = Math.floor(Math.random() * w),
            ry = Math.floor(Math.random() * h);
          if (raw[ry][rx] === "." || raw[ry][rx] === " ") {
            const pos = mapToPx(rx, ry);
            return {
              x: pos.x,
              y: pos.y,
              type: Math.random() < 0.5 ? "heart" : "mana",
              r: 12,
            };
          }
        }
        return null;
      }
      function buildLevel(levelIndex) {
        enemies = [];
        items = [];
        const raw = MAPS[levelIndex];
        const h = raw.length,
          w = raw[0].length;
        mapData = { raw, w, h };
        outer: for (let y = 1; y < h - 1; y++) {
          for (let x = 1; x < w - 1; x++) {
            if (raw[y][x] === "." || raw[y][x] === " ") {
              const p = mapToPx(x, y);
              player.x = p.x;
              player.y = p.y;
              break outer;
            }
          }
        }
        const enemyCount = [6, 9, 12][levelIndex] || 6;
        for (let i = 0; i < enemyCount; i++) {
          let tries = 0;
          while (tries < 400) {
            tries++;
            const rx = Math.floor(Math.random() * w),
              ry = Math.floor(Math.random() * h);
            if (raw[ry][rx] === "." || raw[ry][rx] === " ") {
              const pos = mapToPx(rx, ry);
              if (Math.hypot(pos.x - player.x, pos.y - player.y) < 140)
                continue;
              enemies.push({
                x: pos.x,
                y: pos.y,
                r: 18 + Math.random() * 8,
                hp: 30 + levelIndex * 18 + Math.floor(Math.random() * 30),
                speed: 40 + levelIndex * 10 + Math.random() * 30,
                type:
                  levelIndex === 2 && Math.random() < 0.15 ? "boss" : "grunt",
                _hitCooldown: 0,
                _stuckTimer: 0,
              });
              break;
            }
          }
        }
        for (let i = 0; i < 4; i++) items.push(randomItem(raw));
        let exit = null;
        for (let y = h - 2; y > 0; y--) {
          for (let x = w - 2; x > 0; x--) {
            if (raw[y][x] === "." || raw[y][x] === " ") {
              exit = mapToPx(x, y);
              break;
            }
          }
          if (exit) break;
        }
        mapData.exit = exit;
        return mapData;
      }

      /* =============================
   INPUT
   ============================= */
      const keys = {};
      window.addEventListener("keydown", (e) => {
        const k = (e.key || "").toLowerCase();
        keys[k] = true;
        if (e.code === "Space") keys["space"] = true;
        if (e.key === " ") keys["space"] = true;
        if (e.key === "Escape") {
          if (state === "dialog" || state === "upgrade") hideOverlay();
        }
      });
      window.addEventListener("keyup", (e) => {
        const k = (e.key || "").toLowerCase();
        keys[k] = false;
        if (e.code === "Space") keys["space"] = false;
      });

      /* =============================
   AUDIO
   ============================= */
      let audioCtx = null;
      function ensureAudio() {
        if (!audioCtx)
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      function playBeep(freq, dur = 0.06, vol = 0.06) {
        ensureAudio();
        const o = audioCtx.createOscillator(),
          g = audioCtx.createGain();
        o.type = "sine";
        o.frequency.value = freq;
        g.gain.value = vol;
        o.connect(g);
        g.connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + dur);
      }
      function playSuper() {
        ensureAudio();
        const t0 = audioCtx.currentTime;
        const o1 = audioCtx.createOscillator(),
          o2 = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o1.type = "sawtooth";
        o2.type = "sine";
        o1.frequency.value = 220;
        o2.frequency.value = 330;
        g.gain.value = 0.14;
        o1.connect(g);
        o2.connect(g);
        g.connect(audioCtx.destination);
        o1.start(t0);
        o2.start(t0);
        o1.frequency.exponentialRampToValueAtTime(60, t0 + 0.5);
        o2.frequency.exponentialRampToValueAtTime(80, t0 + 0.5);
        g.gain.exponentialRampToValueAtTime(0.001, t0 + 0.72);
        o1.stop(t0 + 0.72);
        o2.stop(t0 + 0.72);
      }

      /* =============================
   COMBAT
   ============================= */
      function performMelee() {
        playBeep(880, 0.06, 0.06);
        enemies.forEach((en) => {
          const dx = en.x - player.x,
            dy = en.y - player.y;
          const ang = Math.atan2(dy, dx);
          const da = Math.abs(normalizeAngle(ang - player.facing));
          if (
            (da < 1.6 && dist(en, player) < player.r + 48) ||
            dist(en, player) < player.r + 24
          ) {
            en.hp -= player.damage;
            const kb = 8;
            en.x += Math.cos(ang) * kb;
            en.y += Math.sin(ang) * kb;
          }
        });
      }
      function performSuper() {
        playSuper();
        flashSuper = 1.0;
        const goy = document.getElementById("goydaText");
        goy.classList.add("show");
        setTimeout(() => goy.classList.remove("show"), 700);
        enemies.forEach((en) => {
          const dx = en.x - player.x,
            dy = en.y - player.y;
          const d = Math.hypot(dx, dy);
          if (d > 160) return;
          const angleToEnemy = Math.atan2(dy, dx);
          const da = Math.abs(normalizeAngle(angleToEnemy - player.facing));
          if (da < 0.7) {
            en.hp -= BALANCE.superDamage;
            en._hitCooldown = 0.5;
          }
        });
      }

      /* =============================
   UI OVERLAYS
   ============================= */
      const overlayRoot = document.getElementById("overlayRoot");
      function showOverlay(html) {
        // –∑–∞–ø–æ–º–Ω–∏–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, —á—Ç–æ–±—ã –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –≤–µ—Ä–Ω—É—Ç—å –µ–≥–æ –Ω–∞–∑–∞–¥
        prevState = state;
        console.log("[showOverlay] prevState =", prevState);
        overlayRoot.innerHTML = "";
        const wrap = document.createElement("div");
        wrap.className = "dialog";
        wrap.innerHTML = html;
        overlayRoot.style.display = "flex";
        overlayRoot.appendChild(wrap);
        state = "dialog";
        console.log('[showOverlay] state set to "dialog"');
      }

      function hideOverlay() {
        overlayRoot.style.display = "none";
        overlayRoot.innerHTML = "";

        // –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (–µ—Å–ª–∏ –æ–Ω–æ –±—ã–ª–æ)
        if (prevState !== null) {
          state = prevState;
          prevState = null;
        } else {
          // –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –ø–æ—Å—Ç–∞–≤–∏–º –ª–æ–≥–∏—á–µ—Å–∫–∏
          state =
            enemies.length === 0 && mapData && mapData.exit
              ? "gotoExit"
              : "playing";
        }
        console.log(
          "[hideOverlay] restored state =",
          state,
          " (enemies=",
          enemies.length,
          ")"
        );

        // –í–ê–ñ–ù–û: –µ—Å–ª–∏ –º—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –∞–∫—Ç–∏–≤–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ ‚Äî —É–±–µ–¥–∏–º—Å—è, —á—Ç–æ –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª –∑–∞–ø—É—â–µ–Ω
        if (state === "playing" || state === "gotoExit") {
          lastTime = performance.now(); // –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç –±–æ–ª—å—à–æ–π dt –Ω–∞ –ø–µ—Ä–≤–æ–º –∫–∞–¥—Ä–µ
          requestAnimationFrame(loop); // –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏–º —Ü–∏–∫–ª, –µ—Å–ª–∏ –æ–Ω –æ—Å—Ç–∞–Ω–æ–≤–∏–ª—Å—è
          console.log("[hideOverlay] requested animation frame to resume loop");
        }
      }

      function showUpgradeOptions(onPick) {
        const html = `<h3>–í—ã–±–æ—Ä –Ω–∞–≥—Ä–∞–¥—ã</h3><div class="muted">–í—ã–±–µ—Ä–∏ –æ–¥–∏–Ω –∏–∑ —Ç—Ä—ë—Ö –¥–∞—Ä–æ–≤.</div>
    <div class="choices" id="choiceBox">
      <div class="choice" data-choice="hp">+20 –∫ –º–∞–∫—Å HP</div>
      <div class="choice" data-choice="dmg">+6 –∫ —É—Ä–æ–Ω—É</div>
      <div class="choice" data-choice="mana">+30 –∫ –º–∞–Ω–µ</div>
    </div>`;
        showOverlay(html);
        document.getElementById("choiceBox").addEventListener(
          "click",
          (e) => {
            const c = e.target.closest(".choice");
            if (!c) return;
            const val = c.dataset.choice;
            hideOverlay();
            onPick(val);
          },
          { once: true }
        );
      }
      function showEnemyDialog(levelIndex, onContinue) {
        const taunts = [
          "–•–∞! –¢—ã –¥—É–º–∞–µ—à—å, –ª—ã—Å–∏–Ω–æ—é –Ω–∞—Å –∏—Å–ø—É–≥–∞–µ—à—å?",
          "–°–∞–ª–æ ‚Äî —Ç–∞—Ä–µ–ª–∫–∞, –Ω–µ –≤—Ä–∞–≥. –ù–æ –º—ã –ø–æ—Å—Ç–æ–∏–º!",
          "–†—ã–±–Ω–∞—è –ª–µ–Ω—Ç–∞ ‚Äî –ª–∏—à—å –ø–µ—Ä–≤–∞—è –ø—Ä–µ–≥—Ä–∞–¥–∞ –Ω–∞ –ø—É—Ç–∏ –∫ –ì–û–ô–î–ï.",
        ];
        const html = `<h3>–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫:</h3><div class="muted">${
          taunts[levelIndex] || "..."
        }</div>
    <div style="margin-top:12px" class="center"><button class="btn" id="contBtn">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button></div>`;
        showOverlay(html);
        document.getElementById("contBtn").addEventListener(
          "click",
          () => {
            hideOverlay();
            onContinue();
          },
          { once: true }
        );
      }
      function showEnd(title, text) {
        const html = `<h3>${title}</h3><div class="muted" style="margin-top:6px">${text}</div>
    <div style="margin-top:12px" class="choices">
      <div class="choice" id="replay">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</div>
      <div class="choice" id="claim">–ó–∞–±—Ä–∞—Ç—å –ø–æ–¥–∞—Ä–æ–∫</div>
    </div>`;
        showOverlay(html);
        document.getElementById("replay").addEventListener(
          "click",
          () => {
            hideOverlay();
            startGame();
          },
          { once: true }
        );
        document.getElementById("claim").addEventListener(
          "click",
          () => {
            hideOverlay();
            alert("–ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –ü–æ–¥–∞—Ä–∏ –°—Ç–µ–ø–∞–Ω—É –µ–≥–æ –∫–æ—Ä–æ–±–∫—É üéÅ");
          },
          { once: true }
        );
      }

      /* =============================
   GAME FLOW
   ============================= */
      function startGame() {
        currentLevel = 0;
        score = 0;
        player.hp = BALANCE.playerMaxHP;
        player.mana = BALANCE.playerMaxMana;
        player.damage = BALANCE.baseDamage;
        state = "playing";
        loadImages(ASSETS, () => {
          startLevel(currentLevel);
          lastTime = performance.now();
          requestAnimationFrame(loop);
        });
      }
      function startLevel(idx) {
        buildLevel(idx);
        attackCooldown = 0;
        superCooldown = 0;
        flashSuper = 0;
        let exitPulse = 0; // –¥–ª—è –ø—É–ª—å—Å–∞—Ü–∏–∏ –º–∞—Ä–∫–µ—Ä–∞ –≤—ã—Ö–æ–¥–∞
        state = "playing";
      }

      /* =============================
   MAIN LOOP
   ============================= */
      function loop(ts) {
        const dt = Math.min(
          0.05,
          ((ts || performance.now()) - lastTime) / 1000
        );
        lastTime = ts || performance.now();
        if (state === "playing" || state === "gotoExit") {
          update(dt);
          render();
          updateHUD();
        }
        if (state === "playing" || state === "gotoExit")
          requestAnimationFrame(loop);
      }

      /* =============================
   UPDATE
   ============================= */
      function update(dt) {
        let mx = 0,
          my = 0;
        if (keys["arrowup"] || keys["w"]) my -= 1;
        if (keys["arrowdown"] || keys["s"]) my += 1;
        if (keys["arrowleft"] || keys["a"]) mx -= 1;
        if (keys["arrowright"] || keys["d"]) mx += 1;
        const len = Math.hypot(mx, my) || 1;
        movePlayerBy(
          (mx / len) * player.speed * dt,
          (my / len) * player.speed * dt
        );

        if ((keys[" "] || keys["space"]) && attackCooldown <= 0) {
          performMelee();
          attackCooldown = 0.28;
        }
        if (attackCooldown > 0) attackCooldown -= dt;

        if (
          (keys["e"] || keys["—ë"]) &&
          superCooldown <= 0 &&
          player.mana >= BALANCE.superCost
        ) {
          performSuper();
          player.mana -= BALANCE.superCost;
          superCooldown = 1.6;
        }
        if (superCooldown > 0) superCooldown -= dt;

        player.mana = Math.min(BALANCE.playerMaxMana, player.mana + 8 * dt);

        enemies.forEach((en) => {
          const dx = player.x - en.x,
            dy = player.y - en.y;
          const d = Math.hypot(dx, dy) || 1;
          const vx = (dx / d) * en.speed,
            vy = (dy / d) * en.speed;
          moveEnemy(en, vx, vy, dt);
          ensureEntityNotInsideWall(en, dt);
          const minD = en.r + player.r - 6;
          if (dist(en, player) < minD) {
            if (!en._hitCooldown || en._hitCooldown <= 0) {
              player.hp -= 8 + (en.type === "boss" ? 10 : 0);
              en._hitCooldown = 0.8;
              playBeep(220, 0.06, 0.06);
            }
          }
          if (en._hitCooldown > 0) en._hitCooldown -= dt;
          if (en.hp <= 0) en._dead = true;
        });
        enemies = enemies.filter((e) => !e._dead);

        for (let i = items.length - 1; i >= 0; i--) {
          const it = items[i];
          if (dist(it, player) < player.r + it.r) {
            if (it.type === "heart") {
              player.hp = Math.min(
                BALANCE.playerMaxHP,
                player.hp + BALANCE.heartHeal
              );
            } else if (it.type === "mana") {
              player.mana = Math.min(
                BALANCE.playerMaxMana,
                player.mana + BALANCE.manaRestore
              );
            }
            items.splice(i, 1);
            playBeep(720, 0.06, 0.06);
          }
        }
        exitPulse += dt * 3.0; // —Ä–µ–≥—É–ª–∏—Ä—É–π —Å–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª—å—Å–∞—Ü–∏–∏ (3.0 ‚Äî –ø—Ä–∏—è—Ç–Ω—ã–π —Ç–µ–º–ø)

        if (enemies.length === 0 && state === "playing") {
          console.log(
            "[LEVEL CLEAR] enemies === 0, setting state -> gotoExit; mapData.exit=",
            !!(mapData && mapData.exit)
          );
          state = "gotoExit";

          // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é
          showOverlay(`<h3>–í—Ä–∞–≥ –ø–æ–≤–µ—Ä–∂–µ–Ω</h3><div class="muted" style="margin-top:8px">${TEXTS.gotoExitText}</div>
    <div style="margin-top:12px" class="center"><button class="btn" id="okContinue">–ü–æ–Ω—è—Ç–Ω–æ</button></div>`);
          // –ø–æ—Å–ª–µ state = 'gotoExit';
          adjustExitToReachable();

          // –ù–∞–¥—ë–∂–Ω–æ –ø–æ–≤–µ—Å–∏–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ ‚Äî —ç–ª–µ–º–µ–Ω—Ç —É–∂–µ —Å–æ–∑–¥–∞–Ω –≤ showOverlay, –Ω–æ –ø—Ä–æ–≤–µ—Ä–∏–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ
          setTimeout(() => {
            const okBtn = document.getElementById("okContinue");
            if (okBtn) {
              okBtn.addEventListener(
                "click",
                () => {
                  console.log("[okContinue] clicked");
                  hideOverlay();
                },
                { once: true }
              );
            } else {
              console.warn(
                "[okContinue] button not found in DOM after showOverlay"
              );
              // –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π —Å—Ä–∞–∑—É –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
              hideOverlay();
            }
          }, 0);
        }

        if (state === "gotoExit" && mapData && mapData.exit) {
          const ex = mapData.exit;
          if (Math.hypot(player.x - ex.x, player.y - ex.y) < 26) {
            state = "pending";
            showEnemyDialog(currentLevel, () => {
              showUpgradeOptions((choice) => {
                if (choice === "hp") {
                  BALANCE.playerMaxHP += 20;
                  player.hp = Math.min(BALANCE.playerMaxHP, player.hp + 20);
                }
                if (choice === "dmg") {
                  player.damage += 6;
                }
                if (choice === "mana") {
                  BALANCE.playerMaxMana += 30;
                  player.mana = Math.min(
                    BALANCE.playerMaxMana,
                    player.mana + 30
                  );
                }
                currentLevel++;
                if (currentLevel >= MAPS.length) {
                  state = "victory";
                  showEnd(TEXTS.victoryTitle, TEXTS.victoryText);
                } else startLevel(currentLevel);
              });
            });
          }
        }

        if (player.hp <= 0 && state !== "gameover") {
          state = "gameover";
          showEnd(TEXTS.gameOverTitle, TEXTS.gameOverText);
        }
      }

      /* =============================
   RENDER
   ============================= */
      function render() {
        ctx.clearRect(0, 0, W, H);
        // --- Camera: center on player and clamp to map bounds ---
        if (mapData && mapData.w && mapData.h) {
          const mapPixelW = mapData.w * TILE;
          const mapPixelH = mapData.h * TILE;

          // —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–∞–º–µ—Ä—É –Ω–∞ –∏–≥—Ä–æ–∫–µ
          camX = Math.round(player.x - W / 2);
          camY = Math.round(player.y - H / 2);

          // –æ–≥—Ä–∞–Ω–∏—á–∏–º, —á—Ç–æ–±—ã –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø—É—Å—Ç–æ—Ç—É –∑–∞ –∫—Ä–∞—è–º–∏ –∫–∞—Ä—Ç—ã
          camX = Math.max(0, Math.min(camX, Math.max(0, mapPixelW - W)));
          camY = Math.max(0, Math.min(camY, Math.max(0, mapPixelH - H)));
        } else {
          camX = 0;
          camY = 0;
        }
        ctx.save();
        ctx.translate(-camX, -camY);
        if (mapData && mapData.raw) {
          // shift drawing by camera

          for (let y = 0; y < mapData.raw.length; y++) {
            for (let x = 0; x < mapData.raw[y].length; x++) {
              const ch = mapData.raw[y][x];
              const px = x * TILE,
                py = y * TILE;
              if (ch === "#") {
                ctx.fillStyle = "#071721";
                ctx.fillRect(px, py, TILE, TILE);
                ctx.fillStyle = "#082a2f";
                ctx.fillRect(px + 6, py + 6, TILE - 12, TILE - 12);
              } else {
                ctx.fillStyle = "#071421";
                ctx.fillRect(px, py, TILE, TILE);
                ctx.fillStyle = "rgba(255,255,255,0.01)";
                ctx.fillRect(px, py + TILE - 3, TILE, 1);
              }
            }
          }
          // draw pulsing exit marker (–∑–∞–º–µ–Ω—è–µ—Ç –ø—Ä–µ–∂–Ω–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã–π –º–∞—Ä–∫–µ—Ä)
          if (mapData && mapData.exit) {
            const ex = mapData.exit;
            // –ø—É–ª—å—Å–∞—Ü–∏—è (–∑–Ω–∞—á–µ–Ω–∏–µ ~1.0..1.12)
            const pulse = 1 + 0.12 * Math.sin(exitPulse);

            // –≤–Ω–µ—à–Ω–µ–µ —Å–≤–µ—á–µ–Ω–∏–µ (–ø—É–ª—å—Å–∏—Ä—É—é—â–µ–µ)
            ctx.save();
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = "#ffd76b";
            ctx.beginPath();
            ctx.arc(ex.x, ex.y, 18 * pulse, 0, Math.PI * 2);
            ctx.shadowColor = "rgba(255,215,107,0.9)";
            ctx.shadowBlur = 20;
            ctx.fill();
            ctx.restore();

            // –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —è—Ä–∫–∏–π –∫—Ä—É–≥ (–æ—Å–Ω–æ–≤–Ω–æ–π –º–∞—Ä–∫–µ—Ä)
            ctx.beginPath();
            ctx.fillStyle = "#ffdb6b";
            ctx.arc(ex.x, ex.y, 10, 0, Math.PI * 2);
            ctx.fill();

            // –º–∞–ª–µ–Ω—å–∫–∞—è —Ç—ë–º–Ω–∞—è –º–µ—Ç–∫–∞/—à—Ç—Ä–∏—Ö (–≤–∏–∑—É–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç—Ä–∞—Å—Ç)
            ctx.fillStyle = "#6b4512";
            ctx.fillRect(ex.x - 3, ex.y - 3, 6, 6);

            // –ø–æ–¥–ø–∏—Å—å –Ω–∞–¥ –º–∞—Ä–∫–µ—Ä–æ–º
            ctx.fillStyle = "#fff7e0";
            ctx.font = "13px Inter, sans-serif";
            ctx.textAlign = "center";
            // –ø–æ–¥–ø–∏—Å—å —Å–ª–µ–≥–∫–∞ –ø–æ–¥–ø—Ä—ã–≥–∏–≤–∞–µ—Ç –≤–º–µ—Å—Ç–µ —Å –ø—É–ª—å—Å–æ–º
            ctx.fillText("–í–´–•–û–î", ex.x, ex.y - 20 - 4 * (pulse - 1));
          }
        }

        items.forEach((it) => {
          if (IMAGES.heart && it.type === "heart")
            ctx.drawImage(IMAGES.heart, it.x - 16, it.y - 16, 32, 32);
          else if (IMAGES.mana && it.type === "mana")
            ctx.drawImage(IMAGES.mana, it.x - 16, it.y - 16, 32, 32);
          else {
            if (it.type === "heart") {
              ctx.fillStyle = "#ff6b6b";
              ctx.beginPath();
              ctx.arc(it.x, it.y, 10, 0, Math.PI * 2);
              ctx.fill();
            } else {
              ctx.fillStyle = "#4aa3ff";
              ctx.fillRect(it.x - 10, it.y - 10, 20, 20);
            }
          }
        });

        enemies.forEach((en) => {
          if (IMAGES.enemy1 && en.type === "grunt")
            ctx.drawImage(IMAGES.enemy1, en.x - 24, en.y - 24, 48, 48);
          else if (IMAGES.boss && en.type === "boss")
            ctx.drawImage(IMAGES.boss, en.x - 36, en.y - 36, 72, 72);
          else {
            ctx.beginPath();
            ctx.fillStyle = en.type === "boss" ? "#ff8b6b" : "#ff6b6b";
            ctx.arc(en.x, en.y, en.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#581515";
            ctx.fillRect(en.x - 6, en.y - 6, 12, 6);
          }
          ctx.fillStyle = "rgba(0,0,0,0.5)";
          ctx.fillRect(en.x - 20, en.y - en.r - 12, 40, 6);
          ctx.fillStyle = "#60d36b";
          const denom = 60 + currentLevel * 40;
          const w = (Math.max(0, en.hp) / denom) * 40;
          ctx.fillRect(en.x - 20, en.y - en.r - 12, Math.max(0, w), 6);
        });

        if (IMAGES.player)
          ctx.drawImage(IMAGES.player, player.x - 28, player.y - 28, 56, 56);
        else {
          ctx.beginPath();
          ctx.fillStyle = "#ffd7a8";
          ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.fillStyle = "rgba(255,255,255,0.26)";
          ctx.ellipse(player.x - 8, player.y - 10, 12, 7, -0.6, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#d99b4b";
          ctx.fillRect(player.x + 6, player.y + 8, 12, 6);
        }

        if (flashSuper > 0) {
          ctx.save();
          ctx.translate(player.x, player.y);
          ctx.rotate(player.facing);
          ctx.globalAlpha = Math.min(0.7, flashSuper);
          ctx.fillStyle = "rgba(217,180,74,0.32)";
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, 160, -0.7, 0.7);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
          flashSuper = Math.max(0, flashSuper - 0.06);
        }

        ctx.fillStyle = "#dbe9ff";
        ctx.font = "14px Inter, sans-serif";
        ctx.fillText(
          `HP: ${Math.max(0, Math.round(player.hp))} / ${BALANCE.playerMaxHP}`,
          12,
          18
        );
        ctx.fillText(
          `Mana: ${Math.max(0, Math.round(player.mana))} / ${
            BALANCE.playerMaxMana
          }`,
          12,
          36
        );
        // restore canvas transform so HUD (screen-space) is not shifted
        ctx.restore();
      }

      /* =============================
   HUD UPDATE and initial
   ============================= */
      function updateHUD() {
        const hpPerc = (Math.max(0, player.hp) / BALANCE.playerMaxHP) * 100;
        const manaPerc =
          (Math.max(0, player.mana) / BALANCE.playerMaxMana) * 100;
        document.getElementById("hpBar").style.width = hpPerc + "%";
        document.getElementById("manaBar").style.width = manaPerc + "%";
        document.getElementById("scoreText").textContent = "–û—á–∫–∏: " + score;
        document.getElementById("levelText").textContent = `–£—Ä–æ–≤–µ–Ω—å: ${
          currentLevel + 1
        } / 3`;
      }
      ctx.fillStyle = "#dbe9ff";
      ctx.font = "18px Inter";
      ctx.fillText('–ù–∞–∂–º–∏ "–°—Ç–∞—Ä—Ç" —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∏—Å–ø—ã—Ç–∞–Ω–∏–µ', W / 2 - 160, H / 2);
      updateHUD();
    </script>
  </body>
</html>
